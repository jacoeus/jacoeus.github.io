<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Blog搭建摘要</title>
    <url>/2020/09/14/Blog%E6%90%AD%E5%BB%BA%E6%91%98%E8%A6%81/</url>
    <content><![CDATA[<p>使用<a href="https://hexo.io/zh-cn/">hexo</a>进行blog搭建，在对blog搭建和next主题进行配置的过程中整理了一些有用的tips，并在下文进行简单的罗列~</p>
<a id="more"></a>

<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><ul>
<li><p>通过在文章中使用 <code>&lt;!-- more --&gt;</code> 手动可以对文章进行截断</p>
</li>
<li><p>在文章的 <a href="https://hexo.io/docs/front-matter.html">front-matter</a> 中添加 <code>description</code>，并提供文章摘录</p>
</li>
<li><p>自动形成摘要，在 <strong>主题配置文件</strong> 中添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto_excerpt:</span><br><span class="line">  enable: true</span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<p>使用<a href="https://github.com/timnew/hexo-console-rename">hexo-console-rename</a>对已生成的文章进行改名</p>
<p>修改文章title，运行<code>hexo rename</code>命令即可将所有文章的title与文件名同步</p>
<hr>
<p>新建文章后自动使用typora打开新建的md文件</p>
<p>在scipts文件夹中新建example.js，并键入如下命令</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> spawn = <span class="built_in">require</span>(<span class="string">&#x27;hexo-util/lib/spawn&#x27;</span>);</span><br><span class="line"></span><br><span class="line">hexo.on(<span class="string">&#x27;new&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  spawn(<span class="string">&#x27;typora&#x27;</span>, [hexo.base_dir, data.path]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>参考博客 <a href="https://leaferx.online/2018/03/17/hexo-auto-open-vscode/">HEXO小技巧在 hexo new 的时候自动用 VS Code 打开新建文章</a></p>
<hr>
<p>Hexo 不支持指定多个同级分类</p>
<p>分类具有顺序性和层次性</p>
<p>标签没有顺序和层次</p>
<p>如果你需要为文章添加多个分类，可以尝试以下 list 中的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- [Diary, PlayStation]</span><br><span class="line">- [Diary, Games]</span><br><span class="line">- [Life]</span><br></pre></td></tr></table></figure>

<hr>
<p>文章可以先以草稿draft形式存储，待编辑完成后发表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new draft &lt;title&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo publish post &lt;title&gt;</span><br></pre></td></tr></table></figure>

<p>草稿默认不会显示在页面中，您可在执行时加上 <code>--draft</code> 参数，或是把 <code>render_drafts</code> 参数设为 <code>true</code> 来预览草稿</p>
<hr>
<p>在文章中插入引言，可包含作者、来源和标题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure>

<p>其他风格</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% cq %&#125;  &#123;% endcq %&#125;</span><br></pre></td></tr></table></figure>

<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>content </p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<p>其他对markdown呈现效果的优化方案：<a href="https://hexo.io/zh-cn/docs/tag-plugins">标签插件（Tag Plugins）</a></p>
<hr>
<p>参考主题配置文件的custom_file_path项，可以在source/_data中建立对应文件来调整前端界面</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker学习&amp;使用Docker构建zeek到kafka的连接</title>
    <url>/2020/09/19/Docker%E5%AD%A6%E4%B9%A0-%E4%BD%BF%E7%94%A8Docker%E6%9E%84%E5%BB%BAzeek%E5%88%B0kafka%E7%9A%84%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<p>记录一个又是在debug的下午，试图通过kafka将zeek解析pcap文件的结果导入Timescaledb，在开心的参照官方给出的使用docker构建zeek到kafka连接的<a href="https://github.com/blacktop/docker-zeek/blob/master/docs/kafka.md">教程</a>复制粘贴的过程中碰到了奇怪的问题<code>can&#39;t update DNS cache</code>，在搜寻解决方案的过程中发现<a href="https://github.com/blacktop/docker-zeek">docker-zeek</a>的作者对类似问题有过解答，表示正在与zeek-kafka plugin的作者进行联系</p>
<p>在尝试解决问题的过程中，对docker进行了简单的学习，也尝试理解blacktop/kafka以及blacktop/zeek:kafka两个容器以及docker容器之间的通信机制，本文就docker的学习内容进行简单的整理</p>
<a id="more"></a>

<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><blockquote><p>Docker 是一个开放源代码软件，是一个开放平台，用于开发应用、交付应用、运行应用。 Docker允许用户将基础设施中的应用单独分割出来，形成更小的颗粒，从而提高交付软件的速度。 Docker容器与虚拟机类似，但二者在原理上不同。</p>
<footer><strong>Docker 维基百科</strong><cite><a href="https://zh.wikipedia.org/zh-cn/Docker">zh.wikipedia.org/zh-cn/Docker</a></cite></footer></blockquote>

<p><a href="https://labs.play-with-docker.com/">https://labs.play-with-docker.com/</a></p>
<p>以下整理了一些作为Docker的使用者（开发者部分有需要后续进行补充，读者也可以参考<a href="https://docs.docker.com/reference/">官方文档</a>进行学习）可能需要的基础内容并就在构建zeek到kafka连接时用到的命令进行解释</p>
<h2 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h2><blockquote>
<p>Docker通过容器化的技术使您能够将应用程序与基础架构分开，从而可以快速交付软件</p>
</blockquote>
<p>Docker提供了在松散隔离的环境（容器）中打包和运行应用程序的功能。隔离和安全性保证了你同一主机上同时运行多个容器。容器是轻量级的，因为它们不需要管理程序的额外负载，而是直接在主机的内核中运行。于是与虚拟机相比，docker容器的空间占用和资源消耗是小一个量级的。以下是官网对容器特性的总结</p>
<ul>
<li><strong>灵活</strong>：即使最复杂的应用程序也可以容器化</li>
<li><strong>轻量级</strong>：容器利用并共享了主机内核，在系统资源方面比虚拟机更有效</li>
<li><strong>可移植</strong>：您可以在本地构建，部署到云并在任何地方运行</li>
<li><strong>松散耦合</strong>：容器是高度自给自足并封装的容器，使您可以在不破坏其他容器的情况下更换或升级它们</li>
<li><strong>可扩展</strong>：可以在数据中心内增加并自动分发容器副本</li>
<li><strong>安全</strong>：容器将激进的约束和隔离应用于流程，而无需用户方面的任何配置</li>
</ul>
<p>我最早使用docker就是将它当做没有图形界面的虚拟机来用（因为存储空间的限制），但这只能说是docker最粗陋的应用</p>
<p>参考<a href="https://docs.docker.com/get-docker/">官网</a>获取docker，然后通过在命令行输入相关命令即可开始使用</p>
<h2 id="Docker常用子命令"><a href="#Docker常用子命令" class="headerlink" title="Docker常用子命令"></a>Docker常用子命令</h2><p>以下整理了一些常用的Docker子命令，更多子命令参考<a href="https://docs.docker.com/engine/reference/commandline/docker/">https://docs.docker.com/engine/reference/commandline/docker/</a></p>
<p><code>docker search [ 镜像名 ]</code>查找相应镜像</p>
<p>然后根据search结果选择具体镜像使用<code>docker pull [ 仓库 ] / [ 镜像名 ]:[ tag ]</code>从<a href="https://hub.docker.com/">docker hub</a>获取相应镜像到本地</p>
<p>使用<code>docker images</code>可以查看本地的镜像</p>
<p><code>docker rmi [ 镜像名 or 镜像 id ]</code>删除镜像</p>
<p>通过<code>docker run [ 参数 ] [ 镜像名 or 镜像 id ] [ 命令 ]</code>可以基于指定镜像创建容器</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>–add-host</td>
<td>[主机名]:[ip]</td>
<td>添加自定义主机到IP的映射</td>
</tr>
<tr>
<td>–detach , -d</td>
<td></td>
<td>后台运行容器, 并返回容器ID</td>
</tr>
<tr>
<td>–dns</td>
<td>[DNS服务器地址]</td>
<td>设置自定义DNS服务器</td>
</tr>
<tr>
<td>–env , -e</td>
<td></td>
<td>设置环境变量</td>
</tr>
<tr>
<td>–expose</td>
<td>[端口号]</td>
<td>开放一个端口或多个端口</td>
</tr>
<tr>
<td>–hostname , -h</td>
<td>[主机名]</td>
<td>设置容器的主机名, 默认随机生成</td>
</tr>
<tr>
<td>–interactive , -i</td>
<td></td>
<td>以交互模式运行容器, 通常与 -t 同时使用；</td>
</tr>
<tr>
<td>–ip</td>
<td>[ipv4地址]</td>
<td>为容器设置IPv4地址 ( 需要使用自定义网络 )</td>
</tr>
<tr>
<td>–link</td>
<td>[其他容器名]:[在该容器中的别名]</td>
<td>与另一个容器建立链接, 在本容器 hosts 文件中加入关联容器的记录，<strong>官方已不推荐使用</strong></td>
</tr>
<tr>
<td>–memory , -m</td>
<td>[内存上限]</td>
<td>容器内存上限</td>
</tr>
<tr>
<td>–name</td>
<td></td>
<td>为容器分配一个名称</td>
</tr>
<tr>
<td>–net</td>
<td>[bridge / host / none / container]</td>
<td>容器的网络连接类型</td>
</tr>
<tr>
<td>-p</td>
<td>[宿主机端口]:[容器内端口]</td>
<td>宿主机到容器的端口映射</td>
</tr>
<tr>
<td>-P</td>
<td></td>
<td>将所有公开的端口发布到随机端口</td>
</tr>
<tr>
<td>–tty , -t</td>
<td></td>
<td>为容器重新分配一个伪输入终端, 通常与 -i 同时使用</td>
</tr>
<tr>
<td>–volume , -v</td>
<td>[宿主机目录路径]:[容器内目录路径]</td>
<td>挂载宿主机的指定目录到容器内的指定目录</td>
</tr>
<tr>
<td>–volumes-from</td>
<td>[其他容器名]</td>
<td>将其他容器的数据卷添加到此容器</td>
</tr>
</tbody></table>
<p>更多选项参考<a href="https://docs.docker.com/engine/reference/commandline/run/">https://docs.docker.com/engine/reference/commandline/run/</a></p>
<p>通过使用<code>docker run</code>命令，可以在宿主机和容器之间建立联系以及在多个容器之间建立复杂的连接</p>
<p><code>docker ps</code>查看运行中的容器</p>
<p><code>docker ps -a</code>查看所有容器</p>
<p>使用<code>docker attach [ 容器名 or 容器 id ]</code>可以进入运行中的容器, 显示该容器的控制台界面</p>
<p><code>docker start/stop/restart/kill/rm/rename [ 容器名 or 容器 id ]</code>启动/停止/重启/强制关闭/删除/重命名容器</p>
<h2 id="–link选项说明"><a href="#–link选项说明" class="headerlink" title="–link选项说明"></a>–link选项说明</h2><p>–link选项实现容器之间连接的方法目前官方不是很推荐，因为容器间共享环境变量会导致一些不可控因素，推荐所有容器在同一个network下来通信的方法，以及用docker-compose来链接2个容器来通信的方法，具体可以参考<a href="https://yeasy.gitbook.io/docker_practice/">Docker —— 从入门到实践</a>的<a href="https://yeasy.gitbook.io/docker_practice/network/linking">容器互联</a>章节</p>
<p>docker run –link可以用来链接2个容器，使得源容器（被链接的容器）和接收容器（主动去链接的容器）之间可以互相通信，并且接收容器可以获取源容器的一些数据</p>
<p>–link选项实现源容器和接收容器之间传递数据是通过以下2种方式：</p>
<ol>
<li><p>设置环境变量</p>
<ul>
<li>当使用–link时，docker会自动在接收容器内创建基于–link参数的环境变量</li>
<li>接收容器还会获取源容器暴露的环境变量，这些变量包括：<ul>
<li>源容器Dockerfile中ENV标签设置的环境变量</li>
<li>源容器用docker run命令创建，命令中包含的 -e或–env或–env-file设置的环境变量</li>
</ul>
</li>
</ul>
</li>
<li><p>更新/etc/hosts文件</p>
<ul>
<li>docker会将源容器的host更新到目标容器的/etc/hosts中</li>
</ul>
</li>
</ol>
<p>参考文章<a href="https://www.jianshu.com/p/21d66ca6115e">https://www.jianshu.com/p/21d66ca6115e</a></p>
<h2 id="docker-run创建zeek以及kafka容器"><a href="#docker-run创建zeek以及kafka容器" class="headerlink" title="docker run创建zeek以及kafka容器"></a>docker run创建zeek以及kafka容器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -d \</span></span><br><span class="line">           --name kafka \</span><br><span class="line">           -p 9092:9092 \</span><br><span class="line">           -e KAFKA_ADVERTISED_HOST_NAME=localhost \</span><br><span class="line">           -e KAFKA_CREATE_TOPICS=&quot;zeek:1:1&quot; \</span><br><span class="line">           blacktop/kafka:0.11</span><br></pre></td></tr></table></figure>

<p>上述命令表示使用blacktop/kafka:0.11镜像建立名为kafka的容器并后台运行，其中建立宿主机9092端口到容器9092端口的映射（kafka默认端口），并给容器赋环境变量<code>KAFKA_ADVERTISED_HOST_NAME=localhost和KAFKA_CREATE_TOPICS=&quot;zeek:1:1&quot;</code></p>
<p>直接运行此命令可以docker会自动pull blacktop/kafka:0.11镜像</p>
<p>另外，通过<code>docker exec -it [容器名] /bin/bash</code>进入容器（在运行时添加-it选项则可以用attach命令直接进入）后输入env可查看环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">exec</span> -it kafka /bin/bash</span></span><br><span class="line">bash-4.4# ls</span><br><span class="line">LICENSE  NOTICE  bin  config  libs  logs  site-docs</span><br><span class="line">bash-4.4# env</span><br><span class="line">KAFKA_ADVERTISED_HOST_NAME=localhost</span><br><span class="line">HOSTNAME=5daf463d588e</span><br><span class="line">PWD=/opt/kafka</span><br><span class="line">HOME=/root</span><br><span class="line">KAFKA_CREATE_TOPICS=zeek:1:1</span><br><span class="line">TERM=xterm</span><br><span class="line">KAFKA_VERSION=0.11.0.2</span><br><span class="line">SHLVL=1</span><br><span class="line">SCALA_VERSION=2.12</span><br><span class="line">PATH=/sbin:/opt/kafka/bin/:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">_=/usr/bin/env</span><br><span class="line">bash-4.4# exit</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>上面的kafka容器作为源容器（被链接的容器），下面是基于blacktop/zeek:kafka镜像构建容器作为接收容器（主动去链接的容器）的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run --rm \</span></span><br><span class="line">         -v `pwd`:/pcap \</span><br><span class="line">         --link kafka:localhost \</span><br><span class="line">         blacktop/zeek:kafka -P -r heartbleed.pcap local &quot;Site::local_nets += &#123; 192.168.11.0/24 &#125;&quot;</span><br></pre></td></tr></table></figure>

<p>其中<code>--rm</code>表示退出时自动删除容器</p>
<p><code>-v &#96;pwd&#96;:/pcap</code>表示挂载宿主机当前目录到容器内/pcap目录</p>
<p><code>--link kafka:localhost</code>可以实现与kafka容器的链接，其中localhost是当前容器在kafka中的别名</p>
<p>另外，在blacktop/zeek:kafka后的部分<code>-P -r heartbleed.pcap local &quot;Site::local_nets += &#123; 192.168.11.0/24 &#125;&quot;</code>是容器默认执行的命令，即在运行<code>docker run</code>命令时会在容器内运行<code>zeek -P -r heartbleed.pcap local &quot;Site::local_nets += &#123; 192.168.11.0/24 &#125;&quot;</code>，即在容器内通过读取pcap文件生成日志文件</p>
<h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><p><a href="https://www.docker.com/">Docker</a> 是个划时代的开源项目，它彻底释放了计算虚拟化的威力，极大提高了应用的维护效率，降低了云计算应用开发的成本。后面有机会会继续对docker的学习整理。另外，从zeek到timescaledb的入库因为使用将log文件转为csv已经实现入库，使用docker以及kafka作为中转的方案也暂时搁置，这方面之后也希望有机会能彻底分析问题来源以及尝试用其他方法构建容器间的连接</p>
]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>Zeek</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/09/13/Hello-World/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>TimescaleDB学习</title>
    <url>/2020/09/16/TimescaleDB%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><a href="https://docs.timescale.com/latest/main">TimescaleDB</a>是基于关系数据库PostgreSQL的一个开源时序数据库</p>
<p>在股票价格预测、物联网传感器数据变动、网络流量异常检测等场景下，时间这个因素在整个数据分析过程中尤为重要，因此在处理大量类似数据的时候，便需要TimescaleDB或其他时序数据库来实现高效的数据存取</p>
<p>最近尝试对网络流量的时序特征进行提取分析，于是开始学习TimescaleDB，并就主要内容进行整理</p>
<a id="more"></a>

<h1 id="TimescaleDB"><a href="#TimescaleDB" class="headerlink" title="TimescaleDB"></a>TimescaleDB</h1><p>TimescaleDB是作为PostgreSQL上的一个扩展来进行实现的，在PostgreSQL的基础上定义了一些抽象概念并实现了一系列相关API，这部分主要对TimescaleDB的一些设计实现进行简单的整理，下一章节会介绍PostgreSQL的SQL语法等内容，然后就TimescaleDB的一些简单应用进行说明</p>
<h2 id="时序数据"><a href="#时序数据" class="headerlink" title="时序数据"></a>时序数据</h2><p>TimescaleDB主要针对时序数据进行设计，下面罗列了时序数据的主要特征</p>
<ul>
<li><strong>Time-centric</strong>: 数据记录始终带有时间戳</li>
<li><strong>Append-only</strong>: 只能以追加的形式插入数据</li>
<li><strong>Recent</strong>: 新数据一般是在最近一个interval时间间隔的数据</li>
</ul>
<h2 id="Data-model"><a href="#Data-model" class="headerlink" title="Data model"></a>Data model</h2><p>根据时序数据的特征，TimescaleDB为用户提供了两种<a href="https://docs.timescale.com/latest/introduction/data-model">数据模型</a>：窄表模型和宽表模型</p>
<p>在大多情况下，我们使用宽表模型来对数据进行存储，也就是一个时间戳配合当前时间点一系列数据（指标）</p>
<ul>
<li><p>Narrow-table Model，有兴趣进一步了解可以参考<a href="https://docs.timescale.com/latest/introduction/data-model">官方文档</a>，下面只进行简单的描述</p>
<ul>
<li>使用一组唯一的标签集合来定义时间序列    </li>
<li>适用于需要对每个度量分别收集的情况</li>
</ul>
</li>
<li><p>Wide-table Model</p>
<ul>
<li>与数据流匹配，一个时间戳配合当前时间点一系列数据（指标）</li>
<li>便于多指标查询</li>
<li>针对多个指标仅写入一个时间戳，因此提取速度更快</li>
</ul>
</li>
<li><p>JOINs with Relational Data</p>
<ul>
<li>类似于外键，通过JOIN命令可以进行多表查询</li>
</ul>
</li>
</ul>
<h2 id="Concepts"><a href="#Concepts" class="headerlink" title="Concepts"></a>Concepts</h2><p>TimescaleDB在PostgreSQL基础上定义的一些抽象概念</p>
<p>在timescaledb的简单应用上对这些概念的理解要求不高，需要对大量数据进行更高效的存储则需要结合<a href="https://docs.timescale.com/latest/introduction/architecture">官方文档</a>进一步学习理解</p>
<ul>
<li><p>Hypertables超表，为完成用户交互实现的对单个连续表的抽象，以便通过标准SQL进行查询</p>
<blockquote>
<p>Hypertables in TimescaleDB are designed to be easy to manage and to behave predictably to users familiar with standard PostgreSQL tables</p>
</blockquote>
</li>
<li><p>Chunks块，每个超表被拆分为多个块，通过对每个块对应的时间间隔和分区键的区域进行散列</p>
</li>
<li><p>Native Compression原生压缩，对旧的块进行压缩，操作对用户透明</p>
</li>
<li><p>Single Node vs. Clustering单节点和集群，使用分区实现</p>
</li>
<li><p>Time intervals时间间隔</p>
<ul>
<li>v0.11.0后默认时间间隔为7天</li>
<li>可以通过<code>chunk_time_interval</code>在创建超表时设置时间间隔</li>
<li>创建超表后可以通过<code>set_chunk_time_interval</code>来改变新chunks的时间间隔</li>
<li>需要根据数据速率进行设置</li>
</ul>
</li>
<li><p>Space partitions空间分区</p>
<ul>
<li>空间分区的主要目的是使并行I/O具有相同的时间间隔</li>
<li>针对多个并发查询或者多个磁盘并行读取的情况可以使用区间分区</li>
</ul>
</li>
</ul>
<h2 id="安装-amp-配置"><a href="#安装-amp-配置" class="headerlink" title="安装&amp;配置"></a>安装&amp;配置</h2><p><a href="https://docs.timescale.com/latest/getting-started/installation">https://docs.timescale.com/latest/getting-started/installation</a></p>
<p>在ubuntu上可以直接通过apt命令安装，然后需要在postgresSQL上配置扩展</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">psql -U postgres -h localhost</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">database</span> tutorial;</span><br><span class="line">\c tutorial</span><br><span class="line"><span class="keyword">CREATE</span> EXTENSION <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> timescaledb <span class="keyword">CASCADE</span>;</span><br><span class="line"></span><br><span class="line">psql -U postgres -h localhost -d tutorial</span><br></pre></td></tr></table></figure>

<h1 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h1><p>参考<a href="https://www.postgresql.org/">PostgreSQL官网</a>、<a href="http://www.postgres.cn/index.php/v2/home">PostgreSQL中文社区</a>和<a href="http://www.postgres.cn/docs/10/">手册</a>，可以通过搜索框比较方便的查找相应SQL命令</p>
<p>该部分主要介绍PostgreSQL，然后结合TimescaleDB定义的一些函数给出了一些查询操作的demo</p>
<h2 id="常见的psql命令"><a href="#常见的psql命令" class="headerlink" title="常见的psql命令"></a>常见的psql命令</h2><p>用于在终端对PostgreSQL进行操作</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">动作</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>\l</code></td>
<td align="left">列出可用的数据库</td>
</tr>
<tr>
<td align="left"><code>\c dbname</code></td>
<td align="left">连接到新数据库</td>
</tr>
<tr>
<td align="left"><code>\dt</code></td>
<td align="left">列出可用表</td>
</tr>
<tr>
<td align="left"><code>\d tablename</code></td>
<td align="left">描述给定表的细节</td>
</tr>
<tr>
<td align="left"><code>\dn</code></td>
<td align="left">列出当前数据库中的所有架构</td>
</tr>
<tr>
<td align="left"><code>\df</code></td>
<td align="left">列出当前数据库中的函数</td>
</tr>
<tr>
<td align="left"><code>\h</code></td>
<td align="left">获取有关SQL命令语法的帮助</td>
</tr>
<tr>
<td align="left"><code>\?</code></td>
<td align="left">列出所有<code>psql</code>斜杠命令</td>
</tr>
<tr>
<td align="left"><code>\set</code></td>
<td align="left">系统变量列表</td>
</tr>
<tr>
<td align="left"><code>\timing</code></td>
<td align="left">显示查询执行所需的时间</td>
</tr>
<tr>
<td align="left"><code>\x</code></td>
<td align="left">显示扩展的查询结果</td>
</tr>
<tr>
<td align="left"><code>\q</code></td>
<td align="left">退出 <code>psql</code></td>
</tr>
</tbody></table>
<h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><p>对官方给出的demo选取部分有代表性的进行整理</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> create_hypertable(<span class="string">&#x27;conditions&#x27;</span>, <span class="string">&#x27;time&#x27;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The ‘time’ column used in the <code>create_hypertable</code> function supports timestamp, date, or integer types</p>
</blockquote>
<p>create_hypertable是timescaledb定义的函数，用于建立超表，以conditions表为基础，time列对应为时间戳</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本的建表、插入、查询、修改、删表操作</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> conditions (</span><br><span class="line"> <span class="built_in">time</span>        TIMESTAMPTZ       <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"> location    <span class="built_in">TEXT</span>              <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"> temperature <span class="keyword">DOUBLE</span> <span class="keyword">PRECISION</span>  <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> create_hypertable(<span class="string">&#x27;conditions&#x27;</span>, <span class="string">&#x27;time&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> conditions(<span class="built_in">time</span>, location, temperature)</span><br><span class="line">  <span class="keyword">VALUES</span> (<span class="keyword">NOW</span>(), <span class="string">&#x27;office&#x27;</span>, <span class="number">70.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> conditions <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">time</span> <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> conditions</span><br><span class="line">  <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> humidity <span class="keyword">DOUBLE</span> <span class="keyword">PRECISION</span> <span class="literal">NULL</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> conditions;</span><br></pre></td></tr></table></figure>

<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">TIMESTAMP WITHOUT TIME ZONE <span class="comment">--日期和时间（无时区）</span></span><br><span class="line">TIME <span class="keyword">WITH</span> <span class="built_in">TIME</span> ZONE <span class="comment">--一日内的时间（有时区）</span></span><br><span class="line"><span class="built_in">DATE</span> <span class="comment">--日期</span></span><br><span class="line"><span class="built_in">INTERVAL</span> <span class="comment">--时间间隔</span></span><br></pre></td></tr></table></figure>

<p>PostgreSQL定义的<a href="http://www.postgres.cn/docs/9.4/datatype-datetime.html">日期/时间类型</a></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">NUMERIC(precision, scale) <span class="comment">--可选精度的准确数值数据类型</span></span><br><span class="line">NUMERIC <span class="comment">--创建一个可以存储一个直到实现精度上限的任意精度和标度的数值</span></span><br></pre></td></tr></table></figure>

<p>PostgreSQL定义的<a href="http://www.postgres.cn/docs/9.4/datatype.html">数据类型</a></p>
<h3 id="时间-日期函数和操作符"><a href="#时间-日期函数和操作符" class="headerlink" title="时间/日期函数和操作符"></a>时间/日期函数和操作符</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基于time将conditions表转换为超表，并基于location建立空间二分区</span></span><br><span class="line"><span class="keyword">SELECT</span> create_hypertable(<span class="string">&#x27;conditions&#x27;</span>, <span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;location&#x27;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 按照day对pickup_datetime进行截断并计算每天的记录数量</span></span><br><span class="line"><span class="keyword">SELECT</span> date_trunc(<span class="string">&#x27;day&#x27;</span>, pickup_datetime) <span class="keyword">as</span> <span class="keyword">day</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> rides <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">day</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">day</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- EXTRACT函数从日期/时间数值里抽取子域，比如年、小时等</span></span><br><span class="line"><span class="comment">-- trunc截断（向零靠近）</span></span><br><span class="line"><span class="comment">-- GROUP BY将拥有相同值的行分为一组，进一步可以使用HAVING子句筛选分组</span></span><br><span class="line"><span class="comment">-- 不在GROUP BY中列出的字段只能在聚合表达式中被引用</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  <span class="keyword">EXTRACT</span>(<span class="keyword">hour</span> <span class="keyword">from</span> pickup_datetime) <span class="keyword">as</span> <span class="keyword">hours</span>,</span><br><span class="line">  trunc(<span class="keyword">EXTRACT</span>(<span class="keyword">minute</span> <span class="keyword">from</span> pickup_datetime) / <span class="number">5</span>)*<span class="number">5</span> <span class="keyword">AS</span> five_mins,</span><br><span class="line">  <span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> rides</span><br><span class="line"><span class="keyword">WHERE</span> pickup_datetime &lt; <span class="string">&#x27;2016-01-02 00:00&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">hours</span>, five_mins;</span><br></pre></td></tr></table></figure>

<p>PostgreSQL定义的<a href="http://postgres.cn/docs/9.4/functions-datetime.html">时间/日期函数和操作符</a></p>
<h3 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- JOIN实现多表查询</span></span><br><span class="line"><span class="keyword">SELECT</span> rates.description, <span class="keyword">COUNT</span>(vendor_id) <span class="keyword">AS</span> num_trips <span class="keyword">FROM</span> rides</span><br><span class="line">  <span class="keyword">JOIN</span> rates <span class="keyword">ON</span> rides.rate_code = rates.rate_code</span><br><span class="line">  <span class="keyword">WHERE</span> pickup_datetime &lt; <span class="string">&#x27;2016-02-01&#x27;</span></span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> rates.description</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> rates.description;</span><br></pre></td></tr></table></figure>

<h3 id="WITH"><a href="#WITH" class="headerlink" title="WITH"></a>WITH</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> rides_length <span class="keyword">CASCADE</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> rides_length(</span><br><span class="line">	three_hour <span class="built_in">TIMESTAMP</span> <span class="keyword">WITHOUT</span> <span class="built_in">TIME</span> ZONE <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	trip_length <span class="built_in">INTERVAL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">SELECT</span> create_hypertable(<span class="string">&#x27;rides_length&#x27;</span>, <span class="string">&#x27;three_hour&#x27;</span>);</span><br><span class="line"><span class="comment">-- WITH提供了一种在更大的查询中编写辅助语句的方式</span></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">data</span> <span class="keyword">AS</span> (</span><br><span class="line">	<span class="keyword">SELECT</span></span><br><span class="line">	time_bucket(<span class="string">&#x27;3 hour&#x27;</span>, pickup_datetime) <span class="keyword">AS</span> three_hour,</span><br><span class="line">	<span class="keyword">AVG</span>(trip_length) <span class="keyword">AS</span> <span class="keyword">length</span></span><br><span class="line">	<span class="keyword">FROM</span> rides</span><br><span class="line">	<span class="keyword">WHERE</span></span><br><span class="line">	ST_Distance(pickup_geom, ST_Transform(ST_SetSRID(ST_MakePoint(<span class="number">-74.0113</span>,<span class="number">40.7075</span>),<span class="number">4326</span>),<span class="number">2163</span>)) &lt; <span class="number">400</span> <span class="keyword">AND</span></span><br><span class="line">	ST_Distance(dropoff_geom, ST_Transform(ST_SetSRID(ST_MakePoint(<span class="number">-73.9851</span>,<span class="number">40.7589</span>),<span class="number">4326</span>),<span class="number">2163</span>)) &lt; <span class="number">400</span></span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> three_hour <span class="keyword">ORDER</span> <span class="keyword">BY</span> three_hour</span><br><span class="line">	),</span><br><span class="line"><span class="keyword">period</span> <span class="keyword">AS</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> time_bucket(<span class="string">&#x27;3 hour&#x27;</span>,  no_gaps) three_hour</span><br><span class="line">	<span class="keyword">FROM</span>  generate_series(<span class="string">&#x27;2016-01-01 00:00:00&#x27;</span>::<span class="built_in">timestamp</span>, <span class="string">&#x27;2016-01-31 23:59:59&#x27;</span>, <span class="string">&#x27;3 hour&#x27;</span>) no_gaps</span><br><span class="line">	)</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> rides_length</span><br><span class="line"><span class="keyword">SELECT</span> period.three_hour,</span><br><span class="line">(<span class="keyword">SELECT</span> data.length <span class="keyword">FROM</span> <span class="keyword">data</span></span><br><span class="line">	<span class="keyword">WHERE</span> data.three_hour &lt;= period.three_hour</span><br><span class="line">	<span class="keyword">ORDER</span> <span class="keyword">BY</span> data.three_hour <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">1</span>) <span class="keyword">AS</span> trip_length</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">period</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> period.three_hour;</span><br></pre></td></tr></table></figure>

<h3 id="TimescaleDB自定义函数"><a href="#TimescaleDB自定义函数" class="headerlink" title="TimescaleDB自定义函数"></a>TimescaleDB自定义函数</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 按5 minute对pickup_datetime进行划分</span></span><br><span class="line"><span class="keyword">SELECT</span> time_bucket(<span class="string">&#x27;5 minute&#x27;</span>, pickup_datetime) <span class="keyword">AS</span> five_min, <span class="keyword">count</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> rides</span><br><span class="line"><span class="keyword">WHERE</span> pickup_datetime &lt; <span class="string">&#x27;2016-01-02 00:00&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> five_min</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> five_min;</span><br></pre></td></tr></table></figure>

<p>类似time_bucket，TimescaleDB具有许多自定义的<a href="https://docs.timescale.com/latest/api">SQL函数</a>，可以使时间序列分析变得快速而简单</p>
<h2 id="Scheme-management"><a href="#Scheme-management" class="headerlink" title="Scheme management"></a>Scheme management</h2><p>TimescaleDB支持PostgreSQL支持的所有表对象</p>
<p>设计适当的表对象是使用PostgreSQL的关键部分，为给定的工作负载创建适当的索引和表架构可以显着提高性能</p>
<h3 id="Indexing"><a href="#Indexing" class="headerlink" title="Indexing"></a>Indexing</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> <span class="keyword">ON</span> conditions (location, <span class="built_in">time</span> <span class="keyword">DESC</span>);</span><br></pre></td></tr></table></figure>

<p>可以在将表转换为超表之前或之后执行此操作</p>
<ul>
<li>索引选择取决于数据</li>
<li>对于离散值的列<code>CREATE INDEX ON conditions (location, time DESC);</code></li>
<li>对于连续值的列<code>CREATE INDEX ON conditions (time DESC, temperature);</code></li>
<li>在原有索引的基础上加上<code>time DESC</code>定义复合索引对部分查询实现优化</li>
<li>默认索引<ul>
<li><code>CREATE INDEX ON conditions (time DESC);</code></li>
<li>指定了可选的空间分区，TimescaleDB将自动创建索引<code>CREATE INDEX ON conditions (location, time DESC);</code></li>
</ul>
</li>
</ul>
<h3 id="Triggers"><a href="#Triggers" class="headerlink" title="Triggers"></a>Triggers</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> record_error()</span><br><span class="line">  <span class="keyword">RETURNS</span> <span class="keyword">trigger</span> <span class="keyword">AS</span> $record_error$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"> <span class="keyword">IF</span> NEW.temperature &gt;= <span class="number">1000</span> <span class="keyword">OR</span> NEW.humidity &gt;= <span class="number">1000</span> <span class="keyword">THEN</span></span><br><span class="line">   <span class="keyword">INSERT</span> <span class="keyword">INTO</span> error_conditions</span><br><span class="line">     <span class="keyword">VALUES</span>(NEW.time, NEW.location, NEW.temperature, NEW.humidity);</span><br><span class="line"> <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"> RETURN NEW;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$record_error$ LANGUAGE plpgsql;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> record_error</span><br><span class="line">  <span class="keyword">BEFORE</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> conditions</span><br><span class="line">  <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line">  <span class="keyword">EXECUTE</span> <span class="keyword">PROCEDURE</span> record_error();</span><br></pre></td></tr></table></figure>

<p>当超表插入新行时，触发器调用函数</p>
<blockquote>
<p>TimescaleDB支持触发器的全域：<code>BEFORE INSERT</code>，<code>AFTER INSERT</code>，<code>BEFORE UPDATE</code>，<code>AFTER UPDATE</code>，<code>BEFORE DELETE</code>，<code>AFTER DELETE</code></p>
</blockquote>
<h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h3><p>在超级表上创建，删除或更改约束将传播到块中</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> conditions (</span><br><span class="line">    <span class="built_in">time</span>       TIMESTAMPTZ</span><br><span class="line">    temp       <span class="built_in">FLOAT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    device_id  <span class="built_in">INTEGER</span> <span class="keyword">CHECK</span> (device_id &gt; <span class="number">0</span>),</span><br><span class="line">    location   <span class="built_in">INTEGER</span> <span class="keyword">REFERENCES</span> locations (<span class="keyword">id</span>),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="built_in">time</span>, device_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> create_hypertable(<span class="string">&#x27;conditions&#x27;</span>, <span class="string">&#x27;time&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><a href="https://www.postgresql.org/docs/current/ddl-constraints.html">PostgreSQL Constraints</a></p>
<h3 id="JSON-amp-半结构化数据"><a href="#JSON-amp-半结构化数据" class="headerlink" title="JSON &amp; 半结构化数据"></a>JSON &amp; 半结构化数据</h3><p>TimescaleDB可以使用PostgreSQL中可用的任何数据类型，包括JSON和JSONB</p>
<p>用于存储包含用户定义的字段，即由各个用户定义且随用户而异的字段名称的这类数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> metrics (</span><br><span class="line">  <span class="built_in">time</span> TIMESTAMPTZ,</span><br><span class="line">  user_id <span class="built_in">INT</span>,</span><br><span class="line">  device_id <span class="built_in">INT</span>,</span><br><span class="line">  <span class="keyword">data</span> JSONB</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>类似time，user_id和device_id之类的通用字段被拉到 JSONB 结构之外并存储为列，在表列上的字段访问比在JSONB结构内部更有效</li>
<li>JSONB数据类型（即以二进制格式存储的JSON）在存储开销和查找性能上都优于JSON数据类型</li>
</ul>
<h2 id="Writing-data"><a href="#Writing-data" class="headerlink" title="Writing data"></a>Writing data</h2><p>可以使用标准<code>INSERT</code>SQL命令（<a href="https://www.postgresql.org/docs/current/static/sql-insert.html">PostgreSQL docs</a>）将数据插入到超表中</p>
<p><code>UPDATE</code>SQL命令（<a href="https://www.postgresql.org/docs/current/static/sql-update.html">PostgreSQL docs</a>）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> conditions(<span class="built_in">time</span>, location, temperature, humidity)</span><br><span class="line">  <span class="keyword">VALUES</span> (<span class="keyword">NOW</span>(), <span class="string">&#x27;office&#x27;</span>, <span class="number">70.0</span>, <span class="number">50.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--多行插入</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> conditions</span><br><span class="line">  <span class="keyword">VALUES</span></span><br><span class="line">    (<span class="keyword">NOW</span>(), <span class="string">&#x27;office&#x27;</span>, <span class="number">70.0</span>, <span class="number">50.0</span>),</span><br><span class="line">    (<span class="keyword">NOW</span>(), <span class="string">&#x27;basement&#x27;</span>, <span class="number">66.5</span>, <span class="number">60.0</span>),</span><br><span class="line">    (<span class="keyword">NOW</span>(), <span class="string">&#x27;garage&#x27;</span>, <span class="number">77.0</span>, <span class="number">65.2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--UPDATE</span></span><br><span class="line"><span class="keyword">UPDATE</span> conditions <span class="keyword">SET</span> temperature = <span class="number">70.2</span>, humidity = <span class="number">50.0</span></span><br><span class="line">  <span class="keyword">WHERE</span> <span class="built_in">time</span> = <span class="string">&#x27;2017-07-28 11:42:42.846621+00&#x27;</span> <span class="keyword">AND</span> location = <span class="string">&#x27;office&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--更新多行</span></span><br><span class="line"><span class="keyword">UPDATE</span> conditions <span class="keyword">SET</span> temperature = temperature + <span class="number">0.1</span></span><br><span class="line">  <span class="keyword">WHERE</span> <span class="built_in">time</span> &gt;= <span class="string">&#x27;2017-07-28 11:40&#x27;</span> <span class="keyword">AND</span> <span class="built_in">time</span> &lt; <span class="string">&#x27;2017-07-28 11:50&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--UPSERT</span></span><br><span class="line"><span class="comment">#TODO</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--DELETE</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> conditions <span class="keyword">WHERE</span> temperature &lt; <span class="number">35</span> <span class="keyword">OR</span> humidity &lt; <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> conditions <span class="keyword">WHERE</span> <span class="built_in">time</span> &lt; <span class="keyword">NOW</span>() - <span class="built_in">INTERVAL</span> <span class="string">&#x27;1 month&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>TimescaleDB通过可选<code>ON CONFLICT</code>子句（<a href="https://www.postgresql.org/docs/current/static/sql-insert.html#SQL-ON-CONFLICT">PostgreSQL docs</a>）以与PostgreSQL相同的方式支持UPSERT </p>
<p>运行较大的<code>DELETE</code>操作后，建议用户<code>VACUUM</code>或<code>VACUUM FULL</code>通过超表来回收已删除或废弃的行所占用的存储（<a href="https://www.postgresql.org/docs/current/static/sql-vacuum.html">PostgreSQL docs</a>）</p>
<h2 id="Reading-data"><a href="#Reading-data" class="headerlink" title="Reading data"></a>Reading data</h2><p>可以使用标准<code>SELECT</code>SQL命令（<a href="https://www.postgresql.org/docs/current/static/sql-select.html">PostgreSQL docs</a>）从超表中查询数据，包括使用任意<code>WHERE</code>子句，<code>GROUP BY</code>以及<code>ORDER BY</code>命令，联接，子查询，窗口函数，用户定义函数（UDF），<code>HAVING</code>子句等</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> conditions <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">time</span> <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> conditions</span><br><span class="line">  <span class="keyword">WHERE</span> <span class="built_in">time</span> &gt; <span class="keyword">NOW</span>() - <span class="built_in">INTERVAL</span> <span class="string">&#x27;12 hours&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Information about each 15-min period for each location</span></span><br><span class="line"><span class="comment">-- over the past 3 hours, ordered by time and temperature</span></span><br><span class="line"><span class="keyword">SELECT</span> time_bucket(<span class="string">&#x27;15 minutes&#x27;</span>, <span class="built_in">time</span>) <span class="keyword">AS</span> fifteen_min,</span><br><span class="line">    location, <span class="keyword">COUNT</span>(*),</span><br><span class="line">    <span class="keyword">MAX</span>(temperature) <span class="keyword">AS</span> max_temp,</span><br><span class="line">    <span class="keyword">MAX</span>(humidity) <span class="keyword">AS</span> max_hum</span><br><span class="line">  <span class="keyword">FROM</span> conditions</span><br><span class="line">  <span class="keyword">WHERE</span> <span class="built_in">time</span> &gt; <span class="keyword">NOW</span>() - <span class="built_in">INTERVAL</span> <span class="string">&#x27;3 hours&#x27;</span></span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> fifteen_min, location</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> fifteen_min <span class="keyword">DESC</span>, max_temp <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- How many distinct locations with air conditioning</span></span><br><span class="line"><span class="comment">-- have reported data in the past day</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> location) <span class="keyword">FROM</span> conditions</span><br><span class="line">  <span class="keyword">JOIN</span> locations</span><br><span class="line">    <span class="keyword">ON</span> conditions.location = locations.location</span><br><span class="line">  <span class="keyword">WHERE</span> locations.air_conditioning = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">AND</span> <span class="built_in">time</span> &gt; <span class="keyword">NOW</span>() - <span class="built_in">INTERVAL</span> <span class="string">&#x27;1 day&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Database</category>
        <category>TimescaleDB</category>
      </categories>
      <tags>
        <tag>TimescaleDB</tag>
      </tags>
  </entry>
</search>
