<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Blog搭建摘要</title>
    <url>/2020/09/14/Blog%E6%90%AD%E5%BB%BA%E6%91%98%E8%A6%81/</url>
    <content><![CDATA[<p>使用<a href="https://hexo.io/zh-cn/">hexo</a>进行blog搭建，在对blog搭建和next主题进行配置的过程中整理了一些有用的tips，并在下文进行简单的罗列~</p>
<a id="more"></a>

<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><ul>
<li><p>通过在文章中使用 <code>&lt;!-- more --&gt;</code> 手动可以对文章进行截断</p>
</li>
<li><p>在文章的 <a href="https://hexo.io/docs/front-matter.html">front-matter</a> 中添加 <code>description</code>，并提供文章摘录</p>
</li>
<li><p>自动形成摘要，在 <strong>主题配置文件</strong> 中添加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto_excerpt:</span><br><span class="line">  enable: true</span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<p>使用<a href="https://github.com/timnew/hexo-console-rename">hexo-console-rename</a>对已生成的文章进行改名</p>
<p>修改文章title，运行<code>hexo rename</code>命令即可将所有文章的title与文件名同步</p>
<hr>
<p>新建文章后自动使用typora打开新建的md文件</p>
<p>在scipts文件夹中新建example.js，并键入如下命令</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> spawn = <span class="built_in">require</span>(<span class="string">&#x27;hexo-util/lib/spawn&#x27;</span>);</span><br><span class="line"></span><br><span class="line">hexo.on(<span class="string">&#x27;new&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  spawn(<span class="string">&#x27;typora&#x27;</span>, [hexo.base_dir, data.path]);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>参考博客 <a href="https://leaferx.online/2018/03/17/hexo-auto-open-vscode/">HEXO小技巧在 hexo new 的时候自动用 VS Code 打开新建文章</a></p>
<hr>
<p>Hexo 不支持指定多个同级分类</p>
<p>分类具有顺序性和层次性</p>
<p>标签没有顺序和层次</p>
<p>如果你需要为文章添加多个分类，可以尝试以下 list 中的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- [Diary, PlayStation]</span><br><span class="line">- [Diary, Games]</span><br><span class="line">- [Life]</span><br></pre></td></tr></table></figure>

<hr>
<p>文章可以先以草稿draft形式存储，待编辑完成后发表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new draft &lt;title&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo publish post &lt;title&gt;</span><br></pre></td></tr></table></figure>

<p>草稿默认不会显示在页面中，您可在执行时加上 <code>--draft</code> 参数，或是把 <code>render_drafts</code> 参数设为 <code>true</code> 来预览草稿</p>
<hr>
<p>在文章中插入引言，可包含作者、来源和标题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% blockquote [author[, source]] [link] [source_link_title] %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure>

<p>其他风格</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% cq %&#125;  &#123;% endcq %&#125;</span><br></pre></td></tr></table></figure>

<blockquote class="blockquote-center">
            <i class="fa fa-quote-left"></i>
            <p>content </p>

            <i class="fa fa-quote-right"></i>
          </blockquote>

<p>其他对markdown呈现效果的优化方案：<a href="https://hexo.io/zh-cn/docs/tag-plugins">标签插件（Tag Plugins）</a></p>
<hr>
<p>参考主题配置文件的custom_file_path项，可以在source/_data中建立对应文件来调整前端界面</p>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker学习&amp;使用Docker构建zeek到kafka的连接</title>
    <url>/2020/09/19/Docker%E5%AD%A6%E4%B9%A0-%E4%BD%BF%E7%94%A8Docker%E6%9E%84%E5%BB%BAzeek%E5%88%B0kafka%E7%9A%84%E8%BF%9E%E6%8E%A5/</url>
    <content><![CDATA[<p>记录一个又是在debug的下午，试图通过kafka将zeek解析pcap文件的结果导入Timescaledb，在开心的参照官方给出的使用docker构建zeek到kafka连接的<a href="https://github.com/blacktop/docker-zeek/blob/master/docs/kafka.md">教程</a>复制粘贴的过程中碰到了奇怪的问题<code>can&#39;t update DNS cache</code>，在搜寻解决方案的过程中发现<a href="https://github.com/blacktop/docker-zeek">docker-zeek</a>的作者对类似问题有过解答，表示正在与zeek-kafka plugin的作者进行联系</p>
<p>在尝试解决问题的过程中，对docker进行了简单的学习，也尝试理解blacktop/kafka以及blacktop/zeek:kafka两个容器以及docker容器之间的通信机制，本文就docker的学习内容进行简单的整理</p>
<a id="more"></a>

<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><blockquote><p>Docker 是一个开放源代码软件，是一个开放平台，用于开发应用、交付应用、运行应用。 Docker允许用户将基础设施中的应用单独分割出来，形成更小的颗粒，从而提高交付软件的速度。 Docker容器与虚拟机类似，但二者在原理上不同。</p>
<footer><strong>Docker 维基百科</strong><cite><a href="https://zh.wikipedia.org/zh-cn/Docker">zh.wikipedia.org/zh-cn/Docker</a></cite></footer></blockquote>

<p><a href="https://labs.play-with-docker.com/">https://labs.play-with-docker.com/</a></p>
<p>以下整理了一些作为Docker的使用者（开发者部分有需要后续进行补充，读者也可以参考<a href="https://docs.docker.com/reference/">官方文档</a>进行学习）可能需要的基础内容并就在构建zeek到kafka连接时用到的命令进行解释</p>
<h2 id="Docker容器"><a href="#Docker容器" class="headerlink" title="Docker容器"></a>Docker容器</h2><blockquote>
<p>Docker通过容器化的技术使您能够将应用程序与基础架构分开，从而可以快速交付软件</p>
</blockquote>
<p>Docker提供了在松散隔离的环境（容器）中打包和运行应用程序的功能。隔离和安全性保证了你同一主机上同时运行多个容器。容器是轻量级的，因为它们不需要管理程序的额外负载，而是直接在主机的内核中运行。于是与虚拟机相比，docker容器的空间占用和资源消耗是小一个量级的。以下是官网对容器特性的总结</p>
<ul>
<li><strong>灵活</strong>：即使最复杂的应用程序也可以容器化</li>
<li><strong>轻量级</strong>：容器利用并共享了主机内核，在系统资源方面比虚拟机更有效</li>
<li><strong>可移植</strong>：您可以在本地构建，部署到云并在任何地方运行</li>
<li><strong>松散耦合</strong>：容器是高度自给自足并封装的容器，使您可以在不破坏其他容器的情况下更换或升级它们</li>
<li><strong>可扩展</strong>：可以在数据中心内增加并自动分发容器副本</li>
<li><strong>安全</strong>：容器将激进的约束和隔离应用于流程，而无需用户方面的任何配置</li>
</ul>
<p>我最早使用docker就是将它当做没有图形界面的虚拟机来用（因为存储空间的限制），但这只能说是docker最粗陋的应用</p>
<p>参考<a href="https://docs.docker.com/get-docker/">官网</a>获取docker，然后通过在命令行输入相关命令即可开始使用</p>
<h2 id="Docker常用子命令"><a href="#Docker常用子命令" class="headerlink" title="Docker常用子命令"></a>Docker常用子命令</h2><p>以下整理了一些常用的Docker子命令，更多子命令参考<a href="https://docs.docker.com/engine/reference/commandline/docker/">https://docs.docker.com/engine/reference/commandline/docker/</a></p>
<p><code>docker search [ 镜像名 ]</code>查找相应镜像</p>
<p>然后根据search结果选择具体镜像使用<code>docker pull [ 仓库 ] / [ 镜像名 ]:[ tag ]</code>从<a href="https://hub.docker.com/">docker hub</a>获取相应镜像到本地</p>
<p>使用<code>docker images</code>可以查看本地的镜像</p>
<p><code>docker rmi [ 镜像名 or 镜像 id ]</code>删除镜像</p>
<p>通过<code>docker run [ 参数 ] [ 镜像名 or 镜像 id ] [ 命令 ]</code>可以基于指定镜像创建容器</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>–add-host</td>
<td>[主机名]:[ip]</td>
<td>添加自定义主机到IP的映射</td>
</tr>
<tr>
<td>–detach , -d</td>
<td></td>
<td>后台运行容器, 并返回容器ID</td>
</tr>
<tr>
<td>–dns</td>
<td>[DNS服务器地址]</td>
<td>设置自定义DNS服务器</td>
</tr>
<tr>
<td>–env , -e</td>
<td></td>
<td>设置环境变量</td>
</tr>
<tr>
<td>–expose</td>
<td>[端口号]</td>
<td>开放一个端口或多个端口</td>
</tr>
<tr>
<td>–hostname , -h</td>
<td>[主机名]</td>
<td>设置容器的主机名, 默认随机生成</td>
</tr>
<tr>
<td>–interactive , -i</td>
<td></td>
<td>以交互模式运行容器, 通常与 -t 同时使用；</td>
</tr>
<tr>
<td>–ip</td>
<td>[ipv4地址]</td>
<td>为容器设置IPv4地址 ( 需要使用自定义网络 )</td>
</tr>
<tr>
<td>–link</td>
<td>[其他容器名]:[在该容器中的别名]</td>
<td>与另一个容器建立链接, 在本容器 hosts 文件中加入关联容器的记录，<strong>官方已不推荐使用</strong></td>
</tr>
<tr>
<td>–memory , -m</td>
<td>[内存上限]</td>
<td>容器内存上限</td>
</tr>
<tr>
<td>–name</td>
<td></td>
<td>为容器分配一个名称</td>
</tr>
<tr>
<td>–net</td>
<td>[bridge / host / none / container]</td>
<td>容器的网络连接类型</td>
</tr>
<tr>
<td>-p</td>
<td>[宿主机端口]:[容器内端口]</td>
<td>宿主机到容器的端口映射</td>
</tr>
<tr>
<td>-P</td>
<td></td>
<td>将所有公开的端口发布到随机端口</td>
</tr>
<tr>
<td>–tty , -t</td>
<td></td>
<td>为容器重新分配一个伪输入终端, 通常与 -i 同时使用</td>
</tr>
<tr>
<td>–volume , -v</td>
<td>[宿主机目录路径]:[容器内目录路径]</td>
<td>挂载宿主机的指定目录到容器内的指定目录</td>
</tr>
<tr>
<td>–volumes-from</td>
<td>[其他容器名]</td>
<td>将其他容器的数据卷添加到此容器</td>
</tr>
</tbody></table>
<p>更多选项参考<a href="https://docs.docker.com/engine/reference/commandline/run/">https://docs.docker.com/engine/reference/commandline/run/</a></p>
<p>通过使用<code>docker run</code>命令，可以在宿主机和容器之间建立联系以及在多个容器之间建立复杂的连接</p>
<p><code>docker ps</code>查看运行中的容器</p>
<p><code>docker ps -a</code>查看所有容器</p>
<p>使用<code>docker attach [ 容器名 or 容器 id ]</code>可以进入运行中的容器, 显示该容器的控制台界面</p>
<p><code>docker start/stop/restart/kill/rm/rename [ 容器名 or 容器 id ]</code>启动/停止/重启/强制关闭/删除/重命名容器</p>
<h2 id="–link选项说明"><a href="#–link选项说明" class="headerlink" title="–link选项说明"></a>–link选项说明</h2><p>–link选项实现容器之间连接的方法目前官方不是很推荐，因为容器间共享环境变量会导致一些不可控因素，推荐所有容器在同一个network下来通信的方法，以及用docker-compose来链接2个容器来通信的方法，具体可以参考<a href="https://yeasy.gitbook.io/docker_practice/">Docker —— 从入门到实践</a>的<a href="https://yeasy.gitbook.io/docker_practice/network/linking">容器互联</a>章节</p>
<p>docker run –link可以用来链接2个容器，使得源容器（被链接的容器）和接收容器（主动去链接的容器）之间可以互相通信，并且接收容器可以获取源容器的一些数据</p>
<p>–link选项实现源容器和接收容器之间传递数据是通过以下2种方式：</p>
<ol>
<li><p>设置环境变量</p>
<ul>
<li>当使用–link时，docker会自动在接收容器内创建基于–link参数的环境变量</li>
<li>接收容器还会获取源容器暴露的环境变量，这些变量包括：<ul>
<li>源容器Dockerfile中ENV标签设置的环境变量</li>
<li>源容器用docker run命令创建，命令中包含的 -e或–env或–env-file设置的环境变量</li>
</ul>
</li>
</ul>
</li>
<li><p>更新/etc/hosts文件</p>
<ul>
<li>docker会将源容器的host更新到目标容器的/etc/hosts中</li>
</ul>
</li>
</ol>
<p>参考文章<a href="https://www.jianshu.com/p/21d66ca6115e">https://www.jianshu.com/p/21d66ca6115e</a></p>
<h2 id="docker-run创建zeek以及kafka容器"><a href="#docker-run创建zeek以及kafka容器" class="headerlink" title="docker run创建zeek以及kafka容器"></a>docker run创建zeek以及kafka容器</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -d \</span></span><br><span class="line">           --name kafka \</span><br><span class="line">           -p 9092:9092 \</span><br><span class="line">           -e KAFKA_ADVERTISED_HOST_NAME=localhost \</span><br><span class="line">           -e KAFKA_CREATE_TOPICS=&quot;zeek:1:1&quot; \</span><br><span class="line">           blacktop/kafka:0.11</span><br></pre></td></tr></table></figure>

<p>上述命令表示使用blacktop/kafka:0.11镜像建立名为kafka的容器并后台运行，其中建立宿主机9092端口到容器9092端口的映射（kafka默认端口），并给容器赋环境变量<code>KAFKA_ADVERTISED_HOST_NAME=localhost和KAFKA_CREATE_TOPICS=&quot;zeek:1:1&quot;</code></p>
<p>直接运行此命令可以docker会自动pull blacktop/kafka:0.11镜像</p>
<p>另外，通过<code>docker exec -it [容器名] /bin/bash</code>进入容器（在运行时添加-it选项则可以用attach命令直接进入）后输入env可查看环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker <span class="built_in">exec</span> -it kafka /bin/bash</span></span><br></pre></td></tr></table></figure>

<p>上面的kafka容器作为源容器（被链接的容器），下面是基于blacktop/zeek:kafka镜像构建容器作为接收容器（主动去链接的容器）的命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run --rm \</span></span><br><span class="line">         -v `pwd`:/pcap \</span><br><span class="line">         --link kafka:localhost \</span><br><span class="line">         blacktop/zeek:kafka -P -r heartbleed.pcap local &quot;Site::local_nets += &#123; 192.168.11.0/24 &#125;&quot;</span><br></pre></td></tr></table></figure>

<p>其中<code>--rm</code>表示退出时自动删除容器</p>
<p><code>-v &#96;pwd&#96;:/pcap</code>表示挂载宿主机当前目录到容器内/pcap目录</p>
<p><code>--link kafka:localhost</code>可以实现与kafka容器的链接，其中localhost是当前容器在kafka中的别名</p>
<p>另外，在blacktop/zeek:kafka后的部分<code>-P -r heartbleed.pcap local &quot;Site::local_nets += &#123; 192.168.11.0/24 &#125;&quot;</code>是容器默认执行的命令，即在运行<code>docker run</code>命令时会在容器内运行<code>zeek -P -r heartbleed.pcap local &quot;Site::local_nets += &#123; 192.168.11.0/24 &#125;&quot;</code>，即在容器内通过读取pcap文件生成日志文件</p>
<h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><p><a href="https://www.docker.com/">Docker</a> 是个划时代的开源项目，它彻底释放了计算虚拟化的威力，极大提高了应用的维护效率，降低了云计算应用开发的成本。后面有机会会继续对docker的学习整理。另外，从zeek到timescaledb的入库因为使用将log文件转为csv已经实现入库，使用docker以及kafka作为中转的方案也暂时搁置，这方面之后也希望有机会能彻底分析问题来源以及尝试用其他方法构建容器间的连接</p>
]]></content>
      <tags>
        <tag>Docker</tag>
        <tag>Zeek</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>GBDT协作学习实现</title>
    <url>/2020/11/30/GBDT%E5%8D%8F%E4%BD%9C%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>GBDT梯度提升树因其本身是基于梯度来进行决策树构建的，使得他能够支持无损的分布式决策树构建</p>
<p>通过GBDT结合同态加密技术可以应用于横向联邦学习的情况（数据集的特征保证统一）</p>
<p>GBDT的工程实现包括XGBoost以及LightGBM，两者在几大主流大数据平台有分布式的实现</p>
<a id="more"></a>

<h1 id="GBDT-amp-XGBoost-amp-LightGBM"><a href="#GBDT-amp-XGBoost-amp-LightGBM" class="headerlink" title="GBDT &amp; XGBoost &amp; LightGBM"></a>GBDT &amp; XGBoost &amp; LightGBM</h1><p>GBDT，梯度提升树，使用集成学习的boosting方法，根据当前模型损失函数的负梯度信息来训练新加入的弱分类器，然后将训练好的弱分类器以累加的形式结合到现有模型中。<a href="https://arxiv.org/pdf/1603.02754.pdf">XGBoost</a> 和 <a href="https://papers.nips.cc/paper/2017/file/6449f44a102fde848669bdd9eb6b76fa-Paper.pdf">LightGBM</a>是GBDT的两个工程实现</p>
<h2 id="XGBoost"><a href="#XGBoost" class="headerlink" title="XGBoost"></a>XGBoost</h2><p>XGBoost在GDBT的基础上进行了一些算法和工程方面的优化</p>
<ol>
<li><p><strong>引入二阶导：</strong>GBDT 只用到一阶泰勒展开，而 XGBoost 对损失函数进行了二阶泰勒展开。XGBoost 引入二阶导一方面是为了增加精度，另一方面也是为了能够自定义损失函数，二阶泰勒展开可以近似大量损失函数；</p>
</li>
<li><p><strong>正则项：</strong>XGBoost 在目标函数中加入了正则项，用于控制模型的复杂度。正则项里包含了树的叶子节点个数、叶子节点权重的 L2 范式。正则项降低了模型的方差，使学习出来的模型更加简单，有助于防止过拟合；</p>
</li>
<li><p><strong>Shrinkage（缩减）：</strong>类似于学习率，XGBoost 在进行完一次迭代后，会将叶子节点的权重乘上该系数，主要是为了削弱每棵树的影响，让后面有更大的学习空间；</p>
</li>
<li><p>列抽样：XGBoost 借鉴了随机森林的做法，支持列抽样，不仅能降低过拟合，还能减少计算；</p>
</li>
<li><p>缺失值处理：XGBoost 采用的稀疏感知算法极大的加快了节点分裂的速度；</p>
</li>
<li><p>并行化：块结构可以很好的支持并行计算；</p>
</li>
</ol>
<p>但仍存在如下的缺点</p>
<ol>
<li>虽然利用预排序和近似算法可以降低寻找最佳分裂点的计算量，但在节点分裂过程中仍需要遍历数据集；</li>
<li>预排序过程的空间复杂度过高，不仅需要存储特征值，还需要存储特征对应样本的梯度统计值的索引，相当于消耗了两倍的内存；</li>
</ol>
<h2 id="LightGBM"><a href="#LightGBM" class="headerlink" title="LightGBM"></a>LightGBM</h2><p>LightGBM 由微软提出，主要用于解决 GDBT 在<strong>海量数据</strong>中遇到的问题，以便其可以更好更快地用于工业实践中</p>
<p>LightGBM 为了解决这些问题提出了以下几点解决方案：</p>
<ol>
<li><p>单边梯度抽样算法：对样本进行抽样，减少了大量梯度小的样本；</p>
</li>
<li><p><strong>直方图算法（直方图做差加速）</strong>：将连续的特征离散化为 k 个离散特征，同时构造一个宽度为 k 的直方图用于统计信息（包括 k 个 bin）；</p>
</li>
<li><p>互斥特征捆绑算法：将一些特征进行融合绑定，可以降低特征数量（高维特征往往是稀疏的，特征间可能是互斥的）；</p>
</li>
<li><p>基于最大深度的 Leaf-wise 的垂直生长算法：减少了计算量，配合最大深度的限制防止过拟合，由于每次都需要计算增益最大的节点，所以无法并行分裂；</p>
</li>
<li><p>类别特征最优分割；</p>
</li>
<li><p>特征并行/数据并行/投票并行；</p>
</li>
<li><p>缓存优化；</p>
</li>
</ol>
<h2 id="FATE"><a href="#FATE" class="headerlink" title="FATE"></a>FATE</h2><blockquote>
<p> FATE (Federated AI Technology Enabler) 是微众银行AI部门发起的开源项目，为联邦学习生态系统提供了可靠的安全计算框架。FATE项目使用多方安全计算 (MPC) 以及同态加密 (HE) 技术构建底层安全计算协议，以此支持不同种类的机器学习的安全计算，包括逻辑回归、基于树的算法、深度学习和迁移学习等</p>
</blockquote>
<p>FATE官方网站：<a href="https://fate.fedai.org/">https://fate.fedai.org/</a></p>
<p>在进行协作学习实现时，我们主要参考了FATE的homo-secureboost部分代码，并根据需要进行了一些调整</p>
<ul>
<li>采用全局的近似算法作为最优切分点划分算法，即学习每棵树前就提出候选切分点，并在每次分裂时都采用这种分割；</li>
<li>使用softmax交叉熵损失函数，并取其一阶导和二阶导建立直方图；</li>
<li>实现LightGBM的直方图算法，包括直方图作差加速；</li>
<li>采用类似于XGBoost的Level-wise增长策略，方便并行计算每一层的分裂节点，提高了训练速度，但同时也因为节点增益过小增加了很多不必要的分裂；</li>
<li>稀疏感知算法 TODO</li>
<li>特征选择 TODO</li>
</ul>
<h1 id="协作学习实现"><a href="#协作学习实现" class="headerlink" title="协作学习实现"></a>协作学习实现</h1><p>在具体实现上，通过参考FATE项目的相关代码，实现了</p>
<p>先以二分类问题为例说明协作学习实现的过程和原理，再对多分类问题进行简单说明</p>
<h2 id="大致流程"><a href="#大致流程" class="headerlink" title="大致流程"></a>大致流程</h2><ul>
<li><p>Parameter Server</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">获取全局 Quantile Sketch (merge) &lt;- Worker</span><br><span class="line">计算全局候选分裂点 -&gt; Worker</span><br><span class="line"><span class="keyword">for</span> epoch_idx <span class="keyword">in</span> range(self.boosting_round)：</span><br><span class="line">	获取所有局部 g h &lt;- Worker</span><br><span class="line">    计算全局 g h -&gt; Worker</span><br><span class="line">    <span class="keyword">for</span> dep <span class="keyword">in</span> range(self.max_depth):</span><br><span class="line">        获取全局的梯度直方图 (+) &lt;- Worker</span><br><span class="line">        计算最佳分裂点 -&gt; Worker</span><br></pre></td></tr></table></figure>
</li>
<li><p>Worker</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">计算局部 Quantile Sketch -&gt; PS</span><br><span class="line">初始化(候选分裂点，计算y_hat等) &lt;- PS</span><br><span class="line"><span class="keyword">for</span> epoch_idx <span class="keyword">in</span> range(self.boosting_round)：</span><br><span class="line">	根据 y_hat 计算局部 g h -&gt; PS</span><br><span class="line">	初始化决策树（根据全局 g h 、数据集等建立根节点，初始当前层节点为根节点等） &lt;- PS</span><br><span class="line">    <span class="keyword">for</span> dep <span class="keyword">in</span> range(self.max_depth):</span><br><span class="line">        <span class="keyword">if</span> 树达到最大深度：</span><br><span class="line">        	停止树的构建</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            计算当前层各个节点各个特征的梯度直方图 -&gt; PS</span><br><span class="line">            获取当前层各个节点最佳分裂点 &lt;- PS</span><br><span class="line">            根据最佳分裂点建立下一层节点</span><br><span class="line">    根据叶子节点 weight 预测新的 y_hat</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p><code># TODO</code></p>
<h2 id="Quantile-Sketch获取全局候选节点"><a href="#Quantile-Sketch获取全局候选节点" class="headerlink" title="Quantile Sketch获取全局候选节点"></a>Quantile Sketch获取全局候选节点</h2><ul>
<li>每个worker分别收集对应数据集中每个feature 的所有数值并以Quantile Sketch（GK Sketch）进行存储</li>
<li>参数服务器 PS 汇集所有worker的sketch并merge，得到全局的quantile sketch</li>
<li>根据给定的全局参数 bin_num 确定分位点，查询sketch得到对应的数值</li>
</ul>
<h2 id="梯度计算-amp-数学原理"><a href="#梯度计算-amp-数学原理" class="headerlink" title="梯度计算 &amp; 数学原理"></a>梯度计算 &amp; 数学原理</h2><h3 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h3><ol>
<li><p>GBDT 一般是由 $k$ 个基模型（基决策树）组成的一个加法运算式 $\hat{y_i} = \sum_{t=1}^kf_t(x_i)$ ，其中 $f_k$ 为第 $k$ 个基模型， $\hat{y_i}$ 为第 $i$ 个样本的预测值</p>
<p><img src="f1_xgboost.png" alt="f1_xgboost"></p>
<blockquote>
<p>Tree Ensemble Model. The final prediction for a given example is the sum of predictions from each tree.</p>
</blockquote>
</li>
<li><p>损失函数可由预测值 $\hat{y_i}$ 与真实值  $y_i$ 进行表示，$L = \sum_{i=1}^nl(y_i,\hat{y_i})$ ，其中 n 为样本数量</p>
</li>
<li><p>由于模型的预测精度由模型的偏差和方差共同决定，损失函数代表了模型的偏差，想要方差小则需要简单的模型，所以目标函数由模型的损失函数 $L$ 与抑制模型复杂度的正则项 $\Omega$ 组成，于是建立目标函数：<br>$$<br>Obj = \sum_{i=1}^nl(\hat{y_i},y_i) + \sum_{t=1}^k\Omega(f_t)<br>$$</p>
</li>
<li><p>boosting 模型是前向加法，以第 $t$ 步的模型为例，模型对第 $i$ 个样本 $x_i$ 的预测为 $\hat{y_i}^t = \hat{y_i}^{t-1} + f_t(x_i)$</p>
<p>其中 $\hat{y_i}^{t-1}$ 由第  $t - 1$ 步的模型给出的预测值，是已知常数， $f_t(x_i)$ 是我们这次需要加入的新模型的预测值，此时，目标函数就可以写成：<br>$$<br>Obj^{(t)} = \sum_{i=1}^nl(y_i,\hat{y_i}^t) + \sum_{t=1}^t\Omega(f_i) = \sum_{i=1}^nl(y_i,\hat{y_i}^{t-1}+f_t(x_i)+\sum_{i=1}^t\Omega(f_t))<br>$$<br>求此时最优化目标函数，就相当于求解 $f_t(x_i)$ </p>
</li>
<li><p>根据泰勒公式我们把函数 $f(x+\Delta x)$ 在点 $x$ 处进行泰勒的二阶展开，可得到等式：<br>$$<br>f(x+\Delta x) \approx f(x) + f^{‘’}(x) + \frac{1}{2}f^{‘’}(x)\Delta x^2f(x+\Delta x) \approx f(x) + f^{‘}(x) + \frac{1}{2}f^{‘’}(x)\Delta x^2<br>$$<br>将把 $\hat{y_i}^{t-1}$ 视为 $x$ ， $f_t(x_i)$ 视为 $\Delta x$ ，故可以将目标函数写为 ：<br>$$<br>Obj^{(t)} = \sum_{t=1}^n\left[l(y_i,\hat{y_i}^{t-1}) + g_if_t(x_i) + \frac{1}{2}h_if_t^2(x_i)\right] + \sum_{t=1}^t\Omega(f_i)<br>$$<br>其中 $g_i$ 为损失函数对 $\hat{y_i}^{t-1}$ 的一阶导， $h_i$ 为损失函数对 $\hat{y_i}^{t-1}$ 的二阶导</p>
</li>
<li><p>由于在第 $t$ 步时 $\hat{y_i}^{t-1}$ 其实是一个已知的值，所以 $l(y_i,\hat{y_i}^{t-1})$ 是一个常数，其对函数的优化不会产生影响，因此目标函数可以写成：<br>$$<br>Obj^{(t)} \approx \sum_{t=1}^n\left[g_if_t(x_i) + \frac{1}{2}h_if_t^2(x_i)\right] + \sum_{t=1}^t\Omega(f_i)<br>$$<br>所以只需根据前一步的 $\hat{y_i}^{t-1}$ 求出每一步损失函数的一阶导和二阶导的值，然后最优化目标函数（保证最大的分裂增益），就可以得到一步的  $f(x)$，最后根据加法模型得到一个整体模型</p>
</li>
</ol>
<h3 id="基于决策树的目标函数"><a href="#基于决策树的目标函数" class="headerlink" title="基于决策树的目标函数"></a>基于决策树的目标函数</h3><ol>
<li><p>将决策树定义为 $f_t(x) = w_{q(x)}$ ， $x$ 为某一样本，这里的 $q(x)$ 代表了该样本所处叶子结点上，而 $w_q$ 则代表了叶子结点取值  ，所以 $w_{q(x)}$ 就代表了某个样本$x$（属于 $q(x)$ 叶子节点）的取值  $w$（即预测值）</p>
</li>
<li><p>决策树的复杂度可由叶子数 $T$ 体现，叶子节点越少模型越简单，此外叶子节点也不应该含有过高的权重 $w$ ，因此目标函数的正则项被定义为：<br>$$<br>\Omega(f_t) = \gamma T + \frac{1}{2}\lambda\sum_{j=1}^Tw_j^2<br>$$<br>即决策树模型的复杂度由生成决策树的叶子节点数量 $T$ 和所有节点权重所组成的向量的 $L_2$ 范式共同决定</p>
</li>
<li><p>设 $I_j = {i|q(x_i) = j}$ 为第 $j$ 个叶子节点的样本集合，故我们的目标函数可以写成：<br>$$<br>\begin{aligned}<br>Obj^{(t)} &amp;\approx \sum_{i=1}^n\left[g_if_t(x_i)+\frac{1}{2}h_if_t^2(x_i)\right] + \Omega(f_t)<br>\\&amp;= \sum_{i=1}^n\left[g_iw_{q(x_i)}^2\right] + \gamma T + \frac{1}{2}\lambda\sum_{j=1}^Tw_j^2<br>\\&amp;= \sum_{j=1}^T\left[(\sum_{i\in I_j}g_i)w_j + \frac{1}{2}(\sum_{i\in I_j}h_i + \lambda)w_j^2\right] + \gamma T<br>\end{aligned}<br>$$<br>其中，第二步是遍历所有的样本后求每个样本的损失函数，但样本最终会落在叶子节点上，所以我们也可以遍历叶子节点，然后获取叶子节点上的样本集合，最后在求损失函数。即我们之前样本的集合，现在都改写成叶子结点的集合，由于一个叶子结点有多个样本存在，因此才有了 $\sum_{i\in I_j}g_i$ 和 $\sum_{i\in I_j}h_i$ 这两项，  $w_j$ 为第 $j$ 个叶子节点取值</p>
</li>
<li><p>为简化表达式，定义 $G_j = \sum_{i\in I_j}g_i$ ， $H_j = \sum_{i\in I_j}h_i$ ，则目标函数为：<br>$$<br>Obj^{(t)} = \sum_{j=1}^T\left[G_jw_j + \frac{1}{2}(H_j + \lambda)w_j^2\right] + \gamma T<br>$$<br>这里我们要注意 $G_j$ 和 $H_j$ 是前 $t-1$ 步得到的结果，其值已知可视为常数，只有最后一棵树的叶子节点 $w_j$ 不确定，那么将目标函数对 $w_j$ 求一阶导，并令其等于 $0$ ，则可以求得叶子结点 $j$ 对应的权值：<br>$$<br>w_j^* = -\frac{G_j}{H_j + \lambda}<br>$$<br>所以目标函数可以化简为：<br>$$<br>Obj = -\frac{1}{2}\sum_{j=1}^T\frac{G_j^2}{H_j+\lambda} + \gamma T<br>$$<br><img src="f2_xgboost.png" alt="f2_xgboost"></p>
<blockquote>
<p>Structure Score Calculation. We only need to sum up the gradient and second order gradient statistics on each leaf, then apply the scoring formula to get the quality score.</p>
</blockquote>
<p>上图给出目标函数计算的例子，求每个节点每个样本的一阶导数 $g_i$ 和二阶导数 $h_i$ ，然后针对每个节点对所含样本求和得到的 $G_j$ 和  $H_j$ ，最后遍历决策树的节点即可得到目标函数</p>
</li>
</ol>
<h3 id="Softmax交叉熵损失函数"><a href="#Softmax交叉熵损失函数" class="headerlink" title="Softmax交叉熵损失函数"></a>Softmax交叉熵损失函数</h3><ul>
<li>$Softmax(\hat{y_i}) = y_i log(1 + e^{−\hat{y_i}} ) + (1 − y_i )log(1 + e^{\hat{y_i}} )$</li>
<li>$g_i = \hat{y_i}^{(t-1)} - y_i$</li>
<li>$h_i = \hat{y_i}^{(t-1)} * (1-\hat{y_i}^{(t-1)})$ </li>
<li>$\hat{y_i}^{(t)} = Softmax(w_j^*) = Softmax(-\frac{G_j}{H_j+\lambda}) = Softmax(-\frac{\sum_{i \in I_j}g_i}{\sum_{i \in I_j}h_i + \lambda})$</li>
</ul>
<h2 id="梯度直方图-amp-分裂点计算"><a href="#梯度直方图-amp-分裂点计算" class="headerlink" title="梯度直方图 &amp; 分裂点计算"></a>梯度直方图 &amp; 分裂点计算</h2><blockquote>
<p>梯度直方图：对于一个树结点，扫描树结点上的所有训练样本，根据其特征值，将样本梯度累加到对应的直方图桶中（候选节点将特征的值域分割成n个桶）</p>
</blockquote>
<p><img src="histogram.png" alt="histogram"></p>
<blockquote>
<p>Histogram-based split finding for one feature</p>
</blockquote>
<ol>
<li><p><strong>计算梯度直方图：</strong> 从待处理树节点的队列中取出待处理的树节点，在Worker上，根据本节点的训练数据计算局部一阶和二阶梯度直方图，此时直方图的</p>
</li>
<li><p><strong>同步&amp;合并直方图：</strong> Worker将局部梯度直方图推送到参数服务器，PS节点在接收到Worker发送的局部梯度直方图后，根据梯度直方图对应的树节点，将其加到全局梯度直方图上</p>
<p><img src="f4-LSGBDT.png" alt="f4-LSGBDT"></p>
<blockquote>
<p>Workers construct local histograms for all features and aggregate into global ones.</p>
</blockquote>
</li>
<li><p><strong>寻找最佳分裂点：</strong> Worker根据每个特征的梯度直方图计算对于该特征的最佳分裂点及其增益，选取其中目标函数增益最大的特征以及对应的候选分裂点作为全局的最佳分裂点</p>
</li>
<li><p><strong>分裂树节点：</strong> Worker根据计算得到的最佳分裂点，创建叶子节点，将本节点的训练数据切分到两个叶子节点上。如果树的高度没有达到最大限制，则将两个叶子节点加入到待处理树节点的队列</p>
</li>
</ol>
<h2 id="多分类实现"><a href="#多分类实现" class="headerlink" title="多分类实现"></a>多分类实现</h2><ul>
<li><p>在每一轮boost中对每个class分别训练决策树，将当前类别的 y 值视为 1，其他类别视为 0 进行1 vs rest二分类进行树的构建以及weight的计算</p>
</li>
<li><p>遵循 1 vs rest 分解策略，训练好 $|\mathcal Y|$ 个二分类器后，将每个分类器的实值输出 $W(\boldsymbol{x}) = \sum_{t=1}^T \alpha _tw_t(\boldsymbol{x})$ 用于识别最有可能的多分类类别，即<br>$$<br>H(x) = \underset{y \in \mathcal Y}{\arg\max} H_y(\boldsymbol{x})<br>$$</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>机器学习</tag>
        <tag>协作学习</tag>
        <tag>联邦学习</tag>
        <tag>决策树算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/09/22/Hello-World/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>TimescaleDB学习</title>
    <url>/2020/09/16/TimescaleDB%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p><a href="https://docs.timescale.com/latest/main">TimescaleDB</a>是基于关系数据库PostgreSQL的一个开源时序数据库</p>
<p>在股票价格预测、物联网传感器数据变动、网络流量异常检测等场景下，时间这个因素在整个数据分析过程中尤为重要，因此在处理大量类似数据的时候，便需要TimescaleDB或其他时序数据库来实现高效的数据存取</p>
<p>最近尝试对网络流量的时序特征进行提取分析，于是开始学习TimescaleDB，并就主要内容进行整理</p>
<a id="more"></a>

<h1 id="TimescaleDB"><a href="#TimescaleDB" class="headerlink" title="TimescaleDB"></a>TimescaleDB</h1><p>TimescaleDB是作为PostgreSQL上的一个扩展来进行实现的，在PostgreSQL的基础上定义了一些抽象概念并实现了一系列相关API，这部分主要对TimescaleDB的一些设计实现进行简单的整理，下一章节会介绍PostgreSQL的SQL语法等内容，然后就TimescaleDB的一些简单应用进行说明</p>
<h2 id="时序数据"><a href="#时序数据" class="headerlink" title="时序数据"></a>时序数据</h2><p>TimescaleDB主要针对时序数据进行设计，下面罗列了时序数据的主要特征</p>
<ul>
<li><strong>Time-centric</strong>: 数据记录始终带有时间戳</li>
<li><strong>Append-only</strong>: 只能以追加的形式插入数据</li>
<li><strong>Recent</strong>: 新数据一般是在最近一个interval时间间隔的数据</li>
</ul>
<h2 id="Data-model"><a href="#Data-model" class="headerlink" title="Data model"></a>Data model</h2><p>根据时序数据的特征，TimescaleDB为用户提供了两种<a href="https://docs.timescale.com/latest/introduction/data-model">数据模型</a>：窄表模型和宽表模型</p>
<p>在大多情况下，我们使用宽表模型来对数据进行存储，也就是一个时间戳配合当前时间点一系列数据（指标）</p>
<ul>
<li><p>Narrow-table Model，有兴趣进一步了解可以参考<a href="https://docs.timescale.com/latest/introduction/data-model">官方文档</a>，下面只进行简单的描述</p>
<ul>
<li>使用一组唯一的标签集合来定义时间序列    </li>
<li>适用于需要对每个度量分别收集的情况</li>
</ul>
</li>
<li><p>Wide-table Model</p>
<ul>
<li>与数据流匹配，一个时间戳配合当前时间点一系列数据（指标）</li>
<li>便于多指标查询</li>
<li>针对多个指标仅写入一个时间戳，因此提取速度更快</li>
</ul>
</li>
<li><p>JOINs with Relational Data</p>
<ul>
<li>类似于外键，通过JOIN命令可以进行多表查询</li>
</ul>
</li>
</ul>
<h2 id="Concepts"><a href="#Concepts" class="headerlink" title="Concepts"></a>Concepts</h2><p>TimescaleDB在PostgreSQL基础上定义的一些抽象概念</p>
<p>在timescaledb的简单应用上对这些概念的理解要求不高，需要对大量数据进行更高效的存储则需要结合<a href="https://docs.timescale.com/latest/introduction/architecture">官方文档</a>进一步学习理解</p>
<ul>
<li><p>Hypertables超表，为完成用户交互实现的对单个连续表的抽象，以便通过标准SQL进行查询</p>
<blockquote>
<p>Hypertables in TimescaleDB are designed to be easy to manage and to behave predictably to users familiar with standard PostgreSQL tables</p>
</blockquote>
</li>
<li><p>Chunks块，每个超表被拆分为多个块，通过对每个块对应的时间间隔和分区键的区域进行散列</p>
</li>
<li><p>Native Compression原生压缩，对旧的块进行压缩，操作对用户透明</p>
</li>
<li><p>Single Node vs. Clustering单节点和集群，使用分区实现</p>
</li>
<li><p>Time intervals时间间隔</p>
<ul>
<li>v0.11.0后默认时间间隔为7天</li>
<li>可以通过<code>chunk_time_interval</code>在创建超表时设置时间间隔</li>
<li>创建超表后可以通过<code>set_chunk_time_interval</code>来改变新chunks的时间间隔</li>
<li>需要根据数据速率进行设置</li>
</ul>
</li>
<li><p>Space partitions空间分区</p>
<ul>
<li>空间分区的主要目的是使并行I/O具有相同的时间间隔</li>
<li>针对多个并发查询或者多个磁盘并行读取的情况可以使用区间分区</li>
</ul>
</li>
</ul>
<h2 id="安装-amp-配置"><a href="#安装-amp-配置" class="headerlink" title="安装&amp;配置"></a>安装&amp;配置</h2><p><a href="https://docs.timescale.com/latest/getting-started/installation">https://docs.timescale.com/latest/getting-started/installation</a></p>
<p>在ubuntu上可以直接通过apt命令安装，然后需要在postgresSQL上配置扩展</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">psql -U postgres -h localhost</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">database</span> tutorial;</span><br><span class="line">\c tutorial</span><br><span class="line"><span class="keyword">CREATE</span> EXTENSION <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> timescaledb <span class="keyword">CASCADE</span>;</span><br><span class="line"></span><br><span class="line">psql -U postgres -h localhost -d tutorial</span><br></pre></td></tr></table></figure>

<h1 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h1><p>参考<a href="https://www.postgresql.org/">PostgreSQL官网</a>、<a href="http://www.postgres.cn/index.php/v2/home">PostgreSQL中文社区</a>和<a href="http://www.postgres.cn/docs/10/">手册</a>，可以通过搜索框比较方便的查找相应SQL命令</p>
<p>该部分主要介绍PostgreSQL，然后结合TimescaleDB定义的一些函数给出了一些查询操作的demo</p>
<h2 id="常见的psql命令"><a href="#常见的psql命令" class="headerlink" title="常见的psql命令"></a>常见的psql命令</h2><p>用于在终端对PostgreSQL进行操作</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">动作</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>\l</code></td>
<td align="left">列出可用的数据库</td>
</tr>
<tr>
<td align="left"><code>\c dbname</code></td>
<td align="left">连接到新数据库</td>
</tr>
<tr>
<td align="left"><code>\dt</code></td>
<td align="left">列出可用表</td>
</tr>
<tr>
<td align="left"><code>\d tablename</code></td>
<td align="left">描述给定表的细节</td>
</tr>
<tr>
<td align="left"><code>\dn</code></td>
<td align="left">列出当前数据库中的所有架构</td>
</tr>
<tr>
<td align="left"><code>\df</code></td>
<td align="left">列出当前数据库中的函数</td>
</tr>
<tr>
<td align="left"><code>\h</code></td>
<td align="left">获取有关SQL命令语法的帮助</td>
</tr>
<tr>
<td align="left"><code>\?</code></td>
<td align="left">列出所有<code>psql</code>斜杠命令</td>
</tr>
<tr>
<td align="left"><code>\set</code></td>
<td align="left">系统变量列表</td>
</tr>
<tr>
<td align="left"><code>\timing</code></td>
<td align="left">显示查询执行所需的时间</td>
</tr>
<tr>
<td align="left"><code>\x</code></td>
<td align="left">显示扩展的查询结果</td>
</tr>
<tr>
<td align="left"><code>\q</code></td>
<td align="left">退出 <code>psql</code></td>
</tr>
</tbody></table>
<h2 id="SQL语句"><a href="#SQL语句" class="headerlink" title="SQL语句"></a>SQL语句</h2><p>对官方给出的demo选取部分有代表性的进行整理</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> create_hypertable(<span class="string">&#x27;conditions&#x27;</span>, <span class="string">&#x27;time&#x27;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>The ‘time’ column used in the <code>create_hypertable</code> function supports timestamp, date, or integer types</p>
</blockquote>
<p>create_hypertable是timescaledb定义的函数，用于建立超表，以conditions表为基础，time列对应为时间戳</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基本的建表、插入、查询、修改、删表操作</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> conditions (</span><br><span class="line"> <span class="built_in">time</span>        TIMESTAMPTZ       <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"> location    <span class="built_in">TEXT</span>              <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"> temperature <span class="keyword">DOUBLE</span> <span class="keyword">PRECISION</span>  <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> create_hypertable(<span class="string">&#x27;conditions&#x27;</span>, <span class="string">&#x27;time&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> conditions(<span class="built_in">time</span>, location, temperature)</span><br><span class="line">  <span class="keyword">VALUES</span> (<span class="keyword">NOW</span>(), <span class="string">&#x27;office&#x27;</span>, <span class="number">70.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> conditions <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">time</span> <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> conditions</span><br><span class="line">  <span class="keyword">ADD</span> <span class="keyword">COLUMN</span> humidity <span class="keyword">DOUBLE</span> <span class="keyword">PRECISION</span> <span class="literal">NULL</span>;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> conditions;</span><br></pre></td></tr></table></figure>

<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">TIMESTAMP WITHOUT TIME ZONE <span class="comment">--日期和时间（无时区）</span></span><br><span class="line">TIME <span class="keyword">WITH</span> <span class="built_in">TIME</span> ZONE <span class="comment">--一日内的时间（有时区）</span></span><br><span class="line"><span class="built_in">DATE</span> <span class="comment">--日期</span></span><br><span class="line"><span class="built_in">INTERVAL</span> <span class="comment">--时间间隔</span></span><br></pre></td></tr></table></figure>

<p>PostgreSQL定义的<a href="http://www.postgres.cn/docs/9.4/datatype-datetime.html">日期/时间类型</a></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">NUMERIC(precision, scale) <span class="comment">--可选精度的准确数值数据类型</span></span><br><span class="line">NUMERIC <span class="comment">--创建一个可以存储一个直到实现精度上限的任意精度和标度的数值</span></span><br></pre></td></tr></table></figure>

<p>PostgreSQL定义的<a href="http://www.postgres.cn/docs/9.4/datatype.html">数据类型</a></p>
<h3 id="时间-日期函数和操作符"><a href="#时间-日期函数和操作符" class="headerlink" title="时间/日期函数和操作符"></a>时间/日期函数和操作符</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 基于time将conditions表转换为超表，并基于location建立空间二分区</span></span><br><span class="line"><span class="keyword">SELECT</span> create_hypertable(<span class="string">&#x27;conditions&#x27;</span>, <span class="string">&#x27;time&#x27;</span>, <span class="string">&#x27;location&#x27;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 按照day对pickup_datetime进行截断并计算每天的记录数量</span></span><br><span class="line"><span class="keyword">SELECT</span> date_trunc(<span class="string">&#x27;day&#x27;</span>, pickup_datetime) <span class="keyword">as</span> <span class="keyword">day</span>, <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> rides <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">day</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">day</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- EXTRACT函数从日期/时间数值里抽取子域，比如年、小时等</span></span><br><span class="line"><span class="comment">-- trunc截断（向零靠近）</span></span><br><span class="line"><span class="comment">-- GROUP BY将拥有相同值的行分为一组，进一步可以使用HAVING子句筛选分组</span></span><br><span class="line"><span class="comment">-- 不在GROUP BY中列出的字段只能在聚合表达式中被引用</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  <span class="keyword">EXTRACT</span>(<span class="keyword">hour</span> <span class="keyword">from</span> pickup_datetime) <span class="keyword">as</span> <span class="keyword">hours</span>,</span><br><span class="line">  trunc(<span class="keyword">EXTRACT</span>(<span class="keyword">minute</span> <span class="keyword">from</span> pickup_datetime) / <span class="number">5</span>)*<span class="number">5</span> <span class="keyword">AS</span> five_mins,</span><br><span class="line">  <span class="keyword">COUNT</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> rides</span><br><span class="line"><span class="keyword">WHERE</span> pickup_datetime &lt; <span class="string">&#x27;2016-01-02 00:00&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">hours</span>, five_mins;</span><br></pre></td></tr></table></figure>

<p>PostgreSQL定义的<a href="http://postgres.cn/docs/9.4/functions-datetime.html">时间/日期函数和操作符</a></p>
<h3 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- JOIN实现多表查询</span></span><br><span class="line"><span class="keyword">SELECT</span> rates.description, <span class="keyword">COUNT</span>(vendor_id) <span class="keyword">AS</span> num_trips <span class="keyword">FROM</span> rides</span><br><span class="line">  <span class="keyword">JOIN</span> rates <span class="keyword">ON</span> rides.rate_code = rates.rate_code</span><br><span class="line">  <span class="keyword">WHERE</span> pickup_datetime &lt; <span class="string">&#x27;2016-02-01&#x27;</span></span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> rates.description</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> rates.description;</span><br></pre></td></tr></table></figure>

<h3 id="WITH"><a href="#WITH" class="headerlink" title="WITH"></a>WITH</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> rides_length <span class="keyword">CASCADE</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> rides_length(</span><br><span class="line">	three_hour <span class="built_in">TIMESTAMP</span> <span class="keyword">WITHOUT</span> <span class="built_in">TIME</span> ZONE <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">	trip_length <span class="built_in">INTERVAL</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">SELECT</span> create_hypertable(<span class="string">&#x27;rides_length&#x27;</span>, <span class="string">&#x27;three_hour&#x27;</span>);</span><br><span class="line"><span class="comment">-- WITH提供了一种在更大的查询中编写辅助语句的方式</span></span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">data</span> <span class="keyword">AS</span> (</span><br><span class="line">	<span class="keyword">SELECT</span></span><br><span class="line">	time_bucket(<span class="string">&#x27;3 hour&#x27;</span>, pickup_datetime) <span class="keyword">AS</span> three_hour,</span><br><span class="line">	<span class="keyword">AVG</span>(trip_length) <span class="keyword">AS</span> <span class="keyword">length</span></span><br><span class="line">	<span class="keyword">FROM</span> rides</span><br><span class="line">	<span class="keyword">WHERE</span></span><br><span class="line">	ST_Distance(pickup_geom, ST_Transform(ST_SetSRID(ST_MakePoint(<span class="number">-74.0113</span>,<span class="number">40.7075</span>),<span class="number">4326</span>),<span class="number">2163</span>)) &lt; <span class="number">400</span> <span class="keyword">AND</span></span><br><span class="line">	ST_Distance(dropoff_geom, ST_Transform(ST_SetSRID(ST_MakePoint(<span class="number">-73.9851</span>,<span class="number">40.7589</span>),<span class="number">4326</span>),<span class="number">2163</span>)) &lt; <span class="number">400</span></span><br><span class="line">	<span class="keyword">GROUP</span> <span class="keyword">BY</span> three_hour <span class="keyword">ORDER</span> <span class="keyword">BY</span> three_hour</span><br><span class="line">	),</span><br><span class="line"><span class="keyword">period</span> <span class="keyword">AS</span> (</span><br><span class="line">	<span class="keyword">SELECT</span> time_bucket(<span class="string">&#x27;3 hour&#x27;</span>,  no_gaps) three_hour</span><br><span class="line">	<span class="keyword">FROM</span>  generate_series(<span class="string">&#x27;2016-01-01 00:00:00&#x27;</span>::<span class="built_in">timestamp</span>, <span class="string">&#x27;2016-01-31 23:59:59&#x27;</span>, <span class="string">&#x27;3 hour&#x27;</span>) no_gaps</span><br><span class="line">	)</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> rides_length</span><br><span class="line"><span class="keyword">SELECT</span> period.three_hour,</span><br><span class="line">(<span class="keyword">SELECT</span> data.length <span class="keyword">FROM</span> <span class="keyword">data</span></span><br><span class="line">	<span class="keyword">WHERE</span> data.three_hour &lt;= period.three_hour</span><br><span class="line">	<span class="keyword">ORDER</span> <span class="keyword">BY</span> data.three_hour <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">1</span>) <span class="keyword">AS</span> trip_length</span><br><span class="line"><span class="keyword">FROM</span> <span class="keyword">period</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> period.three_hour;</span><br></pre></td></tr></table></figure>

<h3 id="TimescaleDB自定义函数"><a href="#TimescaleDB自定义函数" class="headerlink" title="TimescaleDB自定义函数"></a>TimescaleDB自定义函数</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 按5 minute对pickup_datetime进行划分</span></span><br><span class="line"><span class="keyword">SELECT</span> time_bucket(<span class="string">&#x27;5 minute&#x27;</span>, pickup_datetime) <span class="keyword">AS</span> five_min, <span class="keyword">count</span>(*)</span><br><span class="line"><span class="keyword">FROM</span> rides</span><br><span class="line"><span class="keyword">WHERE</span> pickup_datetime &lt; <span class="string">&#x27;2016-01-02 00:00&#x27;</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> five_min</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> five_min;</span><br></pre></td></tr></table></figure>

<p>类似time_bucket，TimescaleDB具有许多自定义的<a href="https://docs.timescale.com/latest/api">SQL函数</a>，可以使时间序列分析变得快速而简单</p>
<h2 id="Scheme-management"><a href="#Scheme-management" class="headerlink" title="Scheme management"></a>Scheme management</h2><p>TimescaleDB支持PostgreSQL支持的所有表对象</p>
<p>设计适当的表对象是使用PostgreSQL的关键部分，为给定的工作负载创建适当的索引和表架构可以显着提高性能</p>
<h3 id="Indexing"><a href="#Indexing" class="headerlink" title="Indexing"></a>Indexing</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> <span class="keyword">ON</span> conditions (location, <span class="built_in">time</span> <span class="keyword">DESC</span>);</span><br></pre></td></tr></table></figure>

<p>可以在将表转换为超表之前或之后执行此操作</p>
<ul>
<li>索引选择取决于数据</li>
<li>对于离散值的列<code>CREATE INDEX ON conditions (location, time DESC);</code></li>
<li>对于连续值的列<code>CREATE INDEX ON conditions (time DESC, temperature);</code></li>
<li>在原有索引的基础上加上<code>time DESC</code>定义复合索引对部分查询实现优化</li>
<li>默认索引<ul>
<li><code>CREATE INDEX ON conditions (time DESC);</code></li>
<li>指定了可选的空间分区，TimescaleDB将自动创建索引<code>CREATE INDEX ON conditions (location, time DESC);</code></li>
</ul>
</li>
</ul>
<h3 id="Triggers"><a href="#Triggers" class="headerlink" title="Triggers"></a>Triggers</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> record_error()</span><br><span class="line">  <span class="keyword">RETURNS</span> <span class="keyword">trigger</span> <span class="keyword">AS</span> $record_error$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"> <span class="keyword">IF</span> NEW.temperature &gt;= <span class="number">1000</span> <span class="keyword">OR</span> NEW.humidity &gt;= <span class="number">1000</span> <span class="keyword">THEN</span></span><br><span class="line">   <span class="keyword">INSERT</span> <span class="keyword">INTO</span> error_conditions</span><br><span class="line">     <span class="keyword">VALUES</span>(NEW.time, NEW.location, NEW.temperature, NEW.humidity);</span><br><span class="line"> <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line"> RETURN NEW;</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$record_error$ LANGUAGE plpgsql;</span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> record_error</span><br><span class="line">  <span class="keyword">BEFORE</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> conditions</span><br><span class="line">  <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line">  <span class="keyword">EXECUTE</span> <span class="keyword">PROCEDURE</span> record_error();</span><br></pre></td></tr></table></figure>

<p>当超表插入新行时，触发器调用函数</p>
<blockquote>
<p>TimescaleDB支持触发器的全域：<code>BEFORE INSERT</code>，<code>AFTER INSERT</code>，<code>BEFORE UPDATE</code>，<code>AFTER UPDATE</code>，<code>BEFORE DELETE</code>，<code>AFTER DELETE</code></p>
</blockquote>
<h3 id="Constraints"><a href="#Constraints" class="headerlink" title="Constraints"></a>Constraints</h3><p>在超级表上创建，删除或更改约束将传播到块中</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> conditions (</span><br><span class="line">    <span class="built_in">time</span>       TIMESTAMPTZ</span><br><span class="line">    temp       <span class="built_in">FLOAT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    device_id  <span class="built_in">INTEGER</span> <span class="keyword">CHECK</span> (device_id &gt; <span class="number">0</span>),</span><br><span class="line">    location   <span class="built_in">INTEGER</span> <span class="keyword">REFERENCES</span> locations (<span class="keyword">id</span>),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="built_in">time</span>, device_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> create_hypertable(<span class="string">&#x27;conditions&#x27;</span>, <span class="string">&#x27;time&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><a href="https://www.postgresql.org/docs/current/ddl-constraints.html">PostgreSQL Constraints</a></p>
<h3 id="JSON-amp-半结构化数据"><a href="#JSON-amp-半结构化数据" class="headerlink" title="JSON &amp; 半结构化数据"></a>JSON &amp; 半结构化数据</h3><p>TimescaleDB可以使用PostgreSQL中可用的任何数据类型，包括JSON和JSONB</p>
<p>用于存储包含用户定义的字段，即由各个用户定义且随用户而异的字段名称的这类数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> metrics (</span><br><span class="line">  <span class="built_in">time</span> TIMESTAMPTZ,</span><br><span class="line">  user_id <span class="built_in">INT</span>,</span><br><span class="line">  device_id <span class="built_in">INT</span>,</span><br><span class="line">  <span class="keyword">data</span> JSONB</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>类似time，user_id和device_id之类的通用字段被拉到 JSONB 结构之外并存储为列，在表列上的字段访问比在JSONB结构内部更有效</li>
<li>JSONB数据类型（即以二进制格式存储的JSON）在存储开销和查找性能上都优于JSON数据类型</li>
</ul>
<h2 id="Writing-data"><a href="#Writing-data" class="headerlink" title="Writing data"></a>Writing data</h2><p>可以使用标准<code>INSERT</code>SQL命令（<a href="https://www.postgresql.org/docs/current/static/sql-insert.html">PostgreSQL docs</a>）将数据插入到超表中</p>
<p><code>UPDATE</code>SQL命令（<a href="https://www.postgresql.org/docs/current/static/sql-update.html">PostgreSQL docs</a>）</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> conditions(<span class="built_in">time</span>, location, temperature, humidity)</span><br><span class="line">  <span class="keyword">VALUES</span> (<span class="keyword">NOW</span>(), <span class="string">&#x27;office&#x27;</span>, <span class="number">70.0</span>, <span class="number">50.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--多行插入</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> conditions</span><br><span class="line">  <span class="keyword">VALUES</span></span><br><span class="line">    (<span class="keyword">NOW</span>(), <span class="string">&#x27;office&#x27;</span>, <span class="number">70.0</span>, <span class="number">50.0</span>),</span><br><span class="line">    (<span class="keyword">NOW</span>(), <span class="string">&#x27;basement&#x27;</span>, <span class="number">66.5</span>, <span class="number">60.0</span>),</span><br><span class="line">    (<span class="keyword">NOW</span>(), <span class="string">&#x27;garage&#x27;</span>, <span class="number">77.0</span>, <span class="number">65.2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">--UPDATE</span></span><br><span class="line"><span class="keyword">UPDATE</span> conditions <span class="keyword">SET</span> temperature = <span class="number">70.2</span>, humidity = <span class="number">50.0</span></span><br><span class="line">  <span class="keyword">WHERE</span> <span class="built_in">time</span> = <span class="string">&#x27;2017-07-28 11:42:42.846621+00&#x27;</span> <span class="keyword">AND</span> location = <span class="string">&#x27;office&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--更新多行</span></span><br><span class="line"><span class="keyword">UPDATE</span> conditions <span class="keyword">SET</span> temperature = temperature + <span class="number">0.1</span></span><br><span class="line">  <span class="keyword">WHERE</span> <span class="built_in">time</span> &gt;= <span class="string">&#x27;2017-07-28 11:40&#x27;</span> <span class="keyword">AND</span> <span class="built_in">time</span> &lt; <span class="string">&#x27;2017-07-28 11:50&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">--UPSERT</span></span><br><span class="line"><span class="comment">#TODO</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--DELETE</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> conditions <span class="keyword">WHERE</span> temperature &lt; <span class="number">35</span> <span class="keyword">OR</span> humidity &lt; <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> conditions <span class="keyword">WHERE</span> <span class="built_in">time</span> &lt; <span class="keyword">NOW</span>() - <span class="built_in">INTERVAL</span> <span class="string">&#x27;1 month&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>TimescaleDB通过可选<code>ON CONFLICT</code>子句（<a href="https://www.postgresql.org/docs/current/static/sql-insert.html#SQL-ON-CONFLICT">PostgreSQL docs</a>）以与PostgreSQL相同的方式支持UPSERT </p>
<p>运行较大的<code>DELETE</code>操作后，建议用户<code>VACUUM</code>或<code>VACUUM FULL</code>通过超表来回收已删除或废弃的行所占用的存储（<a href="https://www.postgresql.org/docs/current/static/sql-vacuum.html">PostgreSQL docs</a>）</p>
<h2 id="Reading-data"><a href="#Reading-data" class="headerlink" title="Reading data"></a>Reading data</h2><p>可以使用标准<code>SELECT</code>SQL命令（<a href="https://www.postgresql.org/docs/current/static/sql-select.html">PostgreSQL docs</a>）从超表中查询数据，包括使用任意<code>WHERE</code>子句，<code>GROUP BY</code>以及<code>ORDER BY</code>命令，联接，子查询，窗口函数，用户定义函数（UDF），<code>HAVING</code>子句等</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> conditions <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">time</span> <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> conditions</span><br><span class="line">  <span class="keyword">WHERE</span> <span class="built_in">time</span> &gt; <span class="keyword">NOW</span>() - <span class="built_in">INTERVAL</span> <span class="string">&#x27;12 hours&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Information about each 15-min period for each location</span></span><br><span class="line"><span class="comment">-- over the past 3 hours, ordered by time and temperature</span></span><br><span class="line"><span class="keyword">SELECT</span> time_bucket(<span class="string">&#x27;15 minutes&#x27;</span>, <span class="built_in">time</span>) <span class="keyword">AS</span> fifteen_min,</span><br><span class="line">    location, <span class="keyword">COUNT</span>(*),</span><br><span class="line">    <span class="keyword">MAX</span>(temperature) <span class="keyword">AS</span> max_temp,</span><br><span class="line">    <span class="keyword">MAX</span>(humidity) <span class="keyword">AS</span> max_hum</span><br><span class="line">  <span class="keyword">FROM</span> conditions</span><br><span class="line">  <span class="keyword">WHERE</span> <span class="built_in">time</span> &gt; <span class="keyword">NOW</span>() - <span class="built_in">INTERVAL</span> <span class="string">&#x27;3 hours&#x27;</span></span><br><span class="line">  <span class="keyword">GROUP</span> <span class="keyword">BY</span> fifteen_min, location</span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> fifteen_min <span class="keyword">DESC</span>, max_temp <span class="keyword">DESC</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- How many distinct locations with air conditioning</span></span><br><span class="line"><span class="comment">-- have reported data in the past day</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(<span class="keyword">DISTINCT</span> location) <span class="keyword">FROM</span> conditions</span><br><span class="line">  <span class="keyword">JOIN</span> locations</span><br><span class="line">    <span class="keyword">ON</span> conditions.location = locations.location</span><br><span class="line">  <span class="keyword">WHERE</span> locations.air_conditioning = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">AND</span> <span class="built_in">time</span> &gt; <span class="keyword">NOW</span>() - <span class="built_in">INTERVAL</span> <span class="string">&#x27;1 day&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Database</category>
        <category>TimescaleDB</category>
      </categories>
      <tags>
        <tag>TimescaleDB</tag>
      </tags>
  </entry>
</search>
